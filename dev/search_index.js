var documenterSearchIndex = {"docs":
[{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package is devoted to the forward and inverse problems of Phase Retrieval (PR).","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Forward.jl\"","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"Forward/#Forward-model","page":"Forward model","title":"Forward model","text":"","category":"section"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"For the PR problem, forward model is simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Let's set up a simulation environment matching the following hardware set up: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"using PhaseRetrieval\nlens = PhaseRetrieval.ImagingLens(300mm, 25mm)\ncam = PhaseRetrieval.CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\nims = PhaseRetrieval.ImagingSensor(; lens=lens, cam=cam)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"This creates aperture array of correct dimensions which is suitable for generation of a PSF using Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"p = psf(conf1.ap)\nusing CairoMakie # hide\nCairoMakie.activate!(; type=\"png\") # hide\nheatmap(rotr90(p[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"print(\"Airy size is 1.22λ/NA = \", 1.22 * 632nm * conf1.f / conf1.d / um, \" μm\")","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"lens2 = PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2.ap)\nheatmap(rotr90(p2[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"Forward/#Faster-creation-of-an-ImagingSensor","page":"Forward model","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"keys(camerasdict)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"So the imaging sensor can be created as","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"ims = ImagingSensor(; cam=cam = camerasdict[\"UI1240\"], lens=lensesdict[\"F300A25\"])","category":"page"},{"location":"Forward/#SimConfig","page":"Forward model","title":"SimConfig","text":"","category":"section"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"SimConfig contains necessary information for simulations.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"fieldnames(typeof(conf2))","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"For instance, it contains the aperture mask.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"using PhasePlots\nshowarray(conf2.ap)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in dualroi field and can be used to construct the Zernike basis.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"conf2.dualroi\n\nusing PhaseBases\nbasis = ZernikeBW(conf2.dualroi, conf2.d, 10);\nshowphase(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Or the same picture without unnecssary information (by default all phases will be shown scaled to (-π. π])","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"showphasetight(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"phase = compose(basis, [4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π)\nfig = Figure();\nshowphasetight(phase .* conf2.mask, fig)\nfig","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"For this aberrated phase the PSF is larger","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"p2 = psf(conf2.ap, phase)\nshowarray(p2, :grays)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"More details are visible in the logarithmic scale","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"showarray(PhaseRetrieval.logrescale(p))","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"The SimConfigtype is callable and, if applied to an array of a proper dimensions, generates a psf","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"p2 = conf2(phase)\nshowarray(p2, :grays)","category":"page"},{"location":"Forward/#Inverse-problem","page":"Forward model","title":"Inverse problem","text":"","category":"section"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"The goal of the inverse problem is from given PSF and SimConfig to restore the unknow phase.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"As at this stage the problem is already reduced to its numerical equivalent","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"using FFTW\nusing AlternatingProjections","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"pr = PRproblem(conf2.ap, p)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"a = fftshift(sqrt.(Float64.(conf2.ap)))\nA = fftshift(sqrt.(collect(Float64, p2)))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, ), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"This doesn't work at the moment.  It might work if we let it iterate further","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit =1500), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"(Image: Output after 1500 iterations)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"The phase is perfectly reconstructed now, and  so here is the main problem of the AP-based PR algorthms –- they require quite  a long time to converge, even for the noiseless data.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Let's try to have a smaller crop","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"center = [size(p2)...].÷2\ncrophw=64\npcrop = p2[CartesianIndex(center...) - CartesianIndex(crophw, crophw):CartesianIndex(center...) + CartesianIndex(crophw-1, crophw-1)]\nshowarray(pcrop)","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"Construct corresponding sim config and see how it works TODO wrap all this in functions","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"ims2crop = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=PhaseRetrieval.roi(cam, 2crophw))\nconf2crop = SimConfig(\"10mm aperture\", ims2crop, 633nm)\na = fftshift(sqrt.(Float64.(conf2crop.ap)))\nA = fftshift(sqrt.(collect(Float64, pcrop )))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit=450), APparam(maxit = 10)))","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true), APparam(maxϵ = 0.001)))","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask); current_figure()","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"You can try to change slightly the values of β above and see that algortihm might converge to another solution. This is another problem of AP-based algorithms.","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"Forward/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Gonsalves.jl\"","category":"page"},{"location":"Gonsalves/#Method-of-Gonsalves-for-small-phases","page":"Gonsalves's method","title":"Method of Gonsalves for small phases","text":"","category":"section"},{"location":"Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"","category":"page"},{"location":"Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"#PhaseRetrieval.jl-Documentation","page":"Home","title":"PhaseRetrieval.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n        \"Forward.md\"]\n]\nDepth = 3","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseRetrieval]","category":"page"},{"location":"#PhaseRetrieval.camerasdict","page":"Home","title":"PhaseRetrieval.camerasdict","text":"`camerasdict` is a dictionary with often used cameras.\n\nUse keys(camerasdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.lensesdict","page":"Home","title":"PhaseRetrieval.lensesdict","text":"`lensesdict` is a dictionary with often used cameras.\n\nUse keys(lensesdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.AbstractPRproblem","page":"Home","title":"PhaseRetrieval.AbstractPRproblem","text":"Big class of general phase-retrieval-related problems.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip","page":"Home","title":"PhaseRetrieval.CameraChip","text":"CameraChip(pixelsize = p, imagesize = (sizex, sizey), bitdepth = 8, channelbitdepth = 8 repesent a camera chip with a given pixel size, imagesize, and bitdepth. If omitted,  bitdepth is set to 8.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GS","page":"Home","title":"PhaseRetrieval.GS","text":"Gerchberg-Saxton, classical method to solve PR problem\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GSparam","page":"Home","title":"PhaseRetrieval.GSparam","text":"GSparam(; ϕ⁰, maxit, maxϵ, keephistory, snapshots)\n\nParameters for a concrete realisation of GS method.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingLens","page":"Home","title":"PhaseRetrieval.ImagingLens","text":"Fixed focal length lens\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingSensor","page":"Home","title":"PhaseRetrieval.ImagingSensor","text":"Imaging sensor or camera consists of a lens and camera chip.\n\nCreate a sensor using keyword syntaxis (in any order), lens and cam are required\n\nims = ImagingSensor(lens = ::ImagingLens, cam = ::CameraChip)\n\nOther possible keywords to simulate misalingnment\n\n    focal_distance (= lens.focallength  by default)\n    lensorigin = [0.,0.] # aka nodal point, but expressed in length units\n    # misalingment parameters (not realised yet, set to zero)\n    α = 0.\n    β = 0.\n    γ = 0.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Linear","page":"Home","title":"PhaseRetrieval.Linear","text":"Build SH diversity using the linear functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.MLA","page":"Home","title":"PhaseRetrieval.MLA","text":"Micro-lens array structure. \n\nThe main reason to introduce it separable is to handle the case when camera chip is located not exactly\nin the MLA focal plane.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PDplan","page":"Home","title":"PhaseRetrieval.PDplan","text":"PDplan(plan, diversity)\n\nConstruct Pupil Diversity plan, which, if multiplied by the array a of proper dimensions, computes fft( diversity *a)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblem","page":"Home","title":"PhaseRetrieval.PRproblem","text":"PRproblem(a, A)\n\nClassical phase-retrieval problem of finding complex arrays x, X such that    |x| = a, |X| = A, and X =F(x),  where F denotes the Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Quadratic","page":"Home","title":"PhaseRetrieval.Quadratic","text":"Build SH diversity using the quadratic functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SHSensor","page":"Home","title":"PhaseRetrieval.SHSensor","text":"Shack-Hartmann sensor composed from MLA and a camera. \n\nMLA plane position is defined by distance,  β,  and γ. \nMLA subapertures position is defined by mlaorigin and α.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SimConfig","page":"Home","title":"PhaseRetrieval.SimConfig","text":"SimConfig(name::String, ims::PhaseRetrieval.ImagingSensor, λ::Float64) creates forward-model \nsimulation environment for the PR problem obtained with  `ims` image sensor (camera + lens) at \n    wavelength `λ`. `name` is a sting identifacator used for, for instace, plotting labels.\n\nSimConfig contains the following fields:     julia     name::String     ims::PhaseRetrieval.ImagingSensor     f::Float64     λ::Float64     d::Float64     q::Int     roi::CartesianDomain2D     dualroi::CartesianDomain2D     ap::Array{Float64,2}     mask::Array{Float64,2}`\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.hwConfig-Tuple{String, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.hwConfig","text":"hwConfig(s::String, f, λ, d) creates a hardware configuration with\n`s` camera, lens with a focal length `f` and aperture `d` and using wavelenght\n`λ`.\n\nExample\n\nconf1 = hwConfig(\"UI1540\", 300mm, 633nm,25mm) creates a configuration\nbased on UI-1540 camera, with a 1 inch lens with focal length 300mm and He-Ne laser.\n\n\n\n\n\n","category":"method"},{"location":"#AlternatingProjections.AbstractProblems.solve-Tuple{PRproblem, GSparam, Vararg{Any, 5}}","page":"Home","title":"AlternatingProjections.AbstractProblems.solve","text":"solve(pr::PRproblem, alg::GS, args...)\n\nSolve PR problem using GS method. Any change of the GS parameters can be given \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.SHdiversity","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(size, cellsize, celloffset=0, α=0)\n\nGenerate SH diversity phase of given overall size, cellsize, central cell offset and rotation angle α. \n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.SHdiversity-Tuple{AbstractRange, AbstractRange, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(xrange, yrange, e₁, e₂, o)\n\nGenerate SH diversity phase on array xrange × yrange with cell based on orthogonal grid formed by vectors  e₁, e₂, and origin at o. \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.appsftoPR-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.appsftoPR","text":"appsftoPR(ap,psfimage) constructs a phase retrieval problem from two real arrays, representing the pupil and the focal planes intensity distributions. \n\nThe aperture and PSF are assumed to be centred in the array.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\npsfimage = psf(ap);\n\npr = appsftoPR(ap,psfimage)\n\n# output\nPRproblem{Float64, 2}([1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 4.432323038895129 0.7324956483358351 … 4.432323038895129 6.182768610120748; … ; 8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 10.878351222990858 6.182768610120747 … 10.878351222990858 12.999999999999998])\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.binning-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.binning","text":"binning(arr, Q)\n\nDownsample  array by replacing quadratic cells of size Q × Q by summ of its elements\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.centre-NTuple{5, Any}","page":"Home","title":"PhaseRetrieval.centre","text":"Give centre of an orthogonal grid cell of the grid with cellsize, \ncentre at grid origin and rotated at angle α counterclockwise.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.constructSHPhaseDiversity-Tuple{PhaseRetrieval.SHSensor, Any, Any}","page":"Home","title":"PhaseRetrieval.constructSHPhaseDiversity","text":"constructSHPhaseDiversity(wfs::SHSensor, d, λ )\n\nConstruct SH phase diversity of minimal size for wfs within aperture of diameter d and wavelength λ. Return tuple of arrays for the aperture and phase.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diskmatrix","page":"Home","title":"PhaseRetrieval.diskmatrix","text":"Create array of zeroes with disk of ones of the relative diameter r\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.lineararray","page":"Home","title":"PhaseRetrieval.lineararray","text":"lineararray(xrange, yrange, kx, ky, k0=0)\n\nEvaluate values of linear function kxx + kyy + k0  on array  xrange  yrange.\n\nlineararray(size, kx, ky, k0=0)\n\nUse 1:size as xrange and yrange.\n\nlineararray(xrange, yrange, a::Vector, k0=0)\n\nUse first and second components of vector a as kx and ky.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.logrescale","page":"Home","title":"PhaseRetrieval.logrescale","text":"logrescale(array, α = 5)\n\nRescale in log-scale: maximum will correspond to 1, 10^-α will correspond to 0.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.orthIndexes","page":"Home","title":"PhaseRetrieval.orthIndexes","text":"Generate array of indexes of an orthogonal geometry\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.phwrap-Tuple{AbstractFloat}","page":"Home","title":"PhaseRetrieval.phwrap","text":"Wrap Phase\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.psf-Tuple{AbstractArray}","page":"Home","title":"PhaseRetrieval.psf","text":"psf(amplitude, phase) -> psfimage psf(pupilfield) -> psfimage\n\nCalculate psf for given amplitude and phase.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\n\npsfimage = psf(ap)\n\npsfimage[1]\n\n# output\n\n17.720305330423212\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.quadratic-Tuple{Tuple}","page":"Home","title":"PhaseRetrieval.quadratic","text":"Generate quadratic array\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale","text":"rescale(array)\n\nRescale array between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale_minmax-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale_minmax","text":"rescale_minmax(array)\n\nRescale array between 0 and 1 and return the rescaled array and the min, max values\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.slopearray","page":"Home","title":"PhaseRetrieval.slopearray","text":"slopearray(dom::CartesianDomain2D, dx, dy, k0=0) generates linear array defined on the domain such that\nthe total growth in x and y direction is dx and dy.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.subdivide-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide","text":"subdivide(arr, Q)\n\nSubdivide array of dimension MQ x NQ in Q^2 stacked tiles of size M x N.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.subdivide_sum-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide_sum","text":"subdivide_sum(arr,Q)\n\nDivide array in quadratic cells of size Q × Q  and sum the elements with the same indexes in each cell.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.tile-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.tile","text":"tile(arr, Q)\n\nDivide array in quadratic cells of size Q × Q and stack them along the third dimension.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
