var documenterSearchIndex = {"docs":
[{"location":"Inverse/#Inverse-problem","page":"Introduction","title":"Inverse problem","text":"","category":"section"},{"location":"Inverse/","page":"Introduction","title":"Introduction","text":"The goal of the inverse problem in Phase Retrieval is to reconstruct the phase of the field  in the pupil field from the intensity measurements in the focal plane.","category":"page"},{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package is devoted to the forward and inverse problems of Phase Retrieval (PR).","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Forward.jl\"","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/Forward/#Forward-model","page":"Forward model","title":"Forward model","text":"","category":"section"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"For the PR problem, forward model is simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Let's set up a simulation environment matching the following hardware set up: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"using PhaseRetrieval\nlens = ImagingLens(300mm, 25mm)\ncam = CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\nims = ImagingSensor(lens=lens, cam=cam)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"This creates aperture array of correct dimensions which is suitable for generation of a PSF using Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"p = psf(conf1.ap)\nusing CairoMakie # hide\nCairoMakie.activate!(; type=\"png\") # hide\nheatmap(rotr90(p[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"print(\"Airy size is 1.22λ/NA = \", 1.22 * 632nm * conf1.f / conf1.d / um, \" μm\")","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"lens2 = PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2.ap)\nheatmap(rotr90(p2[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/Forward/#Faster-creation-of-an-ImagingSensor","page":"Forward model","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"keys(camerasdict)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"So the imaging sensor can be created as","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"ims = ImagingSensor(; cam=cam = camerasdict[\"UI1240\"], lens=lensesdict[\"F300A25\"])","category":"page"},{"location":"tutorials/Forward/#SimConfig","page":"Forward model","title":"SimConfig","text":"","category":"section"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"SimConfig contains necessary information for simulations.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"fieldnames(typeof(conf2))","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"For instance, it contains the aperture mask.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"using PhasePlots\nshowarray(conf2.ap)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in dualroi field and can be used to construct the Zernike basis.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"conf2.dualroi","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"This can be used to create the Zernike basis","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"using PhaseBases\nbasis = ZernikeBW(conf2.dualroi, conf2.d, 10);\nshowphase(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Or the same picture without unnecssary information (by default all phases will be shown scaled to (-π. π])","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"showphasetight(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"phase = compose(basis, [4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π)\nfig = Figure();\nshowphasetight(phase .* conf2.mask, fig)\nfig","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"For this aberrated phase the PSF is larger","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"p2 = psf(conf2.ap, phase)\nshowarray(p2, :grays)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"More details are visible in the logarithmic scale","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"showarray(PhaseRetrieval.logrescale(p))","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"The SimConfigtype is callable and, if applied to an array of a proper dimensions, generates a psf","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"p2 = conf2(phase)\nshowarray(p2, :grays)","category":"page"},{"location":"tutorials/Forward/#Inverse-problem","page":"Forward model","title":"Inverse problem","text":"","category":"section"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"The goal of the inverse problem is from given PSF and SimConfig to restore the unknow phase.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"As at this stage the problem is already reduced to its numerical equivalent","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"using FFTW\nusing AlternatingProjections","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"pr = PRproblem(conf2.ap, p)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"a = fftshift(sqrt.(Float64.(conf2.ap)))\nA = fftshift(sqrt.(collect(Float64, p2)))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, ), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"This doesn't work at the moment.  It might work if we let it iterate further","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit =1500), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"(Image: Output after 1500 iterations)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"The phase is perfectly reconstructed now, and  so here is the main problem of the AP-based PR algorthms –- they require quite  a long time to converge, even for the noiseless data.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Let's try to have a smaller crop","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"center = [size(p2)...].÷2\ncrophw=64\npcrop = p2[CartesianIndex(center...) - CartesianIndex(crophw, crophw):CartesianIndex(center...) + CartesianIndex(crophw-1, crophw-1)]\nshowarray(pcrop)","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"Construct corresponding sim config and see how it works TODO wrap all this in functions","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"ims2crop = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=PhaseRetrieval.roi(cam, 2crophw))\nconf2crop = SimConfig(\"10mm aperture\", ims2crop, 633nm)\na = fftshift(sqrt.(Float64.(conf2crop.ap)))\nA = fftshift(sqrt.(collect(Float64, pcrop )))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit=450), APparam(maxit = 10)))","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true), APparam(maxϵ = 0.001)))","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask); current_figure()","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"You can try to change slightly the values of β above and see that algortihm might converge to another solution. This is another problem of AP-based algorithms.","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"tutorials/Forward/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Hardware.jl\"","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/Hardware/#Hardware-types","page":"Hardware types","title":"Hardware types","text":"","category":"section"},{"location":"tutorials/Hardware/#Camera-chip","page":"Hardware types","title":"Camera chip","text":"","category":"section"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"CameraChip represents a device that outputs sampled field intensity, quantized and packed in 8- or 16-bit integer per color channel (currently, only monochrome cameras are implemented).","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"This code sets up a camera with 5.2μm pixel, 1280 × 1024 frame, bitdepth and channeldepth  of 8 bits:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"using PhaseRetrieval\nusing PhasePlots\nusing CairoMakie\nusing ImageCore\ncam = CameraChip(;\n    pixelsize=5.2um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"Cameras can be also created using camerasdict dictionary. Let's consider examples of 8-bit and 12-bit cameras:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam8bit = camerasdict[\"UI1240\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"and","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam12bit = camerasdict[\"UI3860\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"and compare the results of using thes two cameras to measure this  field created by a circular aperture:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"ap,_ = PhaseRetrieval.aperture(-1:.025:1,-1:.025:1,0.9)\n\nshowarray(ap)","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"The field itself is represented by complex array, which has this amplitude and phase (we can see that due to the aperture symmentry, the field in the focal plane is real, actually, and the phase take only values 0 and π):","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"imf = PhaseRetrieval.toimageplane(ap)\nshowarray(abs.(imf)) |> display\nshowphasetight(angle.(imf)); current_figure()","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"And now we can quantize this field by our 8-bit and 12-bit example cameras","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam8bit(imf) |> collect","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam12bit(imf) |> collect","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"note: Note\n","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"We have used collect here, as CameraChip returns a mapped view of the field.","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"We can see that for our 12-bit camera, the measurements are represented by the last 12 bits of a 16-bit number (ImageCore.N4f12(@ref)).","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"We can hardly see the difference in the camera outputs. Compate 8bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam8bit(imf) .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"with 12 bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam12bit(imf) .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"The difference is  visible in logarithmic scale. compare 8bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam8bit(imf) .|> float |> PhaseRetrieval.logrescale .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"and 12 bit","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"cam12bit(imf) .|> float |> PhaseRetrieval.logrescale .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"note: Note\n","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"Here we have used already sampled optical filed imf, so there is no difference in  the sampling rate performed by the cameras. This effect will be demonstrated in the next example.","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"","category":"page"},{"location":"tutorials/Hardware/","page":"Hardware types","title":"Hardware types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"#PhaseRetrieval.jl-Documentation","page":"Home","title":"PhaseRetrieval.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n        \"tutorials/Forward.md\",\n        tutorials/Inverse.md\"\n        ]\n]\nDepth = 3","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseRetrieval]","category":"page"},{"location":"#PhaseRetrieval.camerasdict","page":"Home","title":"PhaseRetrieval.camerasdict","text":"`camerasdict` is a dictionary with often used cameras.\n\nUse keys(camerasdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.lensesdict","page":"Home","title":"PhaseRetrieval.lensesdict","text":"`lensesdict` is a dictionary with often used cameras.\n\nUse keys(lensesdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.storagetype","page":"Home","title":"PhaseRetrieval.storagetype","text":"storagetype[(bitdepth,channelbitdepth)]\n\nGet the storage type returned by the combination of the bit depth and storage depth.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.AbstractPRproblem","page":"Home","title":"PhaseRetrieval.AbstractPRproblem","text":"Big class of general phase-retrieval-related problems.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip","page":"Home","title":"PhaseRetrieval.CameraChip","text":"CameraChip(pixelsize, imagesize; <keyword args>)\n\nCreate a camera chip with a given square pixel size and image size.\n\nYou can also specify the bit depth of the camera and the channel bit depth. For instance, 12-bit camera (bitdepth =12) often transfer its measurement packed in 16-bit number (channelbitdepth = 16).\n\nIf called on a complex field, output the image seen by the chip.\n\nSee also camerasdict, storagetype, intensity.\n\nArguments\n\npixelsize::Float64: size of the pixel. Only square pixels are supported.\nimagesize::Tuple{Int, Int}: (width, height) of the image.\nbitdepth::Int = 8: bit detpth of the camera.\nchannelbitdepth::Int = 8: channel bit depth of the camera. \n\nArguments can be specified in any order.\n\nExample\n\ncam = CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.25:1,-1:.25:1,.8); ap\n9×9 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> imf = PhaseRetrieval.toimageplane(ap);\n\njulia> cam = camerasdict[\"UI3860\"];\n\njulia> cam(imf, AutoExposure(.7)) |> collect\n9×9 Array{N4f12,2} with eltype FixedPointNumbers.N4f12:\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0601  0.0  0.1411  0.4987  0.6999  0.4987  0.1411  0.0  0.0601\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Fourier","page":"Home","title":"PhaseRetrieval.Fourier","text":"Fourier()\n\nFFT-based method of simulation of a PSF.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GS","page":"Home","title":"PhaseRetrieval.GS","text":"Gerchberg-Saxton, classical method to solve PR problem\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GSparam","page":"Home","title":"PhaseRetrieval.GSparam","text":"GSparam(; ϕ⁰, maxit, maxϵ, keephistory, snapshots)\n\nParameters for a concrete realisation of GS method.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingLens","page":"Home","title":"PhaseRetrieval.ImagingLens","text":"ImagingLens(;focallength, aperture)\n\nCreate fixed focal length lens with focus = focallength and aperture dimater aperture.\n\nArguments can be speciefied in any order.\n\nSee also diaphragm, lensesdict.\n\nExample\n\njulia> lens = ImagingLens(300mm, 25mm)\nImagingLens(0.3, 0.025)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingSensor","page":"Home","title":"PhaseRetrieval.ImagingSensor","text":"ImagingSensor(lens=lens, cam=cam)\n\nImaging sensor or camera consisting of a lens lens and camera chip cam.\n\nCreate a sensor using keyword syntaxis (in any order), lens and cam are required\n\nims = ImagingSensor(lens = ::ImagingLens, cam = ::CameraChip)\n\nSee also roi, diaphragm.\n\nArguments:\n\nlens::ImagingLens: lens of the camera\ncam::CameraChip: sensor chip of the camera\n\nIf lens and cam are strings, corresponding values from lensesdict and camerasdict are used.\n\nOther possible keywords to simulate misalingnment (not implemented yet)\n\nfocal_distance = lens.focallength: Distance between the lens and the sensor.\nlensorigin = [0.,0.]: nodal point, expressed in length units (mm or um)\nChip plane misalingment angles: \nα = 0: rotation in x\nβ = 0: rotation in y\nγ = 0: rotation in z\n\nExample\n\njulia> ImagingSensor(lens = ImagingLens(300mm, 25mm),\n           cam = CameraChip(\n               pixelsize=5.2um,\n               imagesize=(1280, 1024),\n               bitdepth=8,\n               channelbitdepth=8\n               )\n           )\nImagingSensor(ImagingLens(0.3, 0.025), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n \njulia> diaphragm(ImagingSensor(lens = lensesdict[\"F300A25\"], cam= camerasdict[\"UI1540\"]), 10mm)\nImagingSensor(ImagingLens(0.3, 0.01), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n \njulia> ImagingSensor(\"F300A25\",  \"UI1540\")\nImagingSensor(ImagingLens(0.3, 0.025), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Linear","page":"Home","title":"PhaseRetrieval.Linear","text":"Build SH diversity using the linear functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.MLA","page":"Home","title":"PhaseRetrieval.MLA","text":"Micro-lens array structure. \n\nThe main reason to introduce it separable is to handle the case when camera chip is located not exactly\nin the MLA focal plane.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PDplan","page":"Home","title":"PhaseRetrieval.PDplan","text":"PDplan(plan, diversity)\n\nConstruct Pupil Diversity plan, which, if multiplied by the array a of proper dimensions, computes fft( diversity *a)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblem","page":"Home","title":"PhaseRetrieval.PRproblem","text":"PRproblem(a, A)\n\nClassical phase-retrieval problem of finding complex arrays x, X such that    |x| = a, |X| = A, and X =F(x),  where F denotes the Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Quadratic","page":"Home","title":"PhaseRetrieval.Quadratic","text":"Build SH diversity using the quadratic functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SHSensor","page":"Home","title":"PhaseRetrieval.SHSensor","text":"Shack-Hartmann sensor composed from MLA and a camera. \n\nMLA plane position is defined by distance,  β,  and γ. \nMLA subapertures position is defined by mlaorigin and α.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SimConfig","page":"Home","title":"PhaseRetrieval.SimConfig","text":"SimConfig(name::String, ims::PhaseRetrieval.ImagingSensor, λ::Float64) creates forward-model \nsimulation environment for the PR problem obtained with  `ims` image sensor (camera + lens) at \n    wavelength `λ`. `name` is a sting identifacator used for, for instace, plotting labels.\n\nSimConfig contains the following fields:     julia     name::String     ims::PhaseRetrieval.ImagingSensor     f::Float64     λ::Float64     d::Float64     q::Int     roi::CartesianDomain2D     dualroi::CartesianDomain2D     ap::Array{Float64,2}     mask::Array{Float64,2}`\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.hwConfig-Tuple{String, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.hwConfig","text":"hwConfig(s::String, f, λ, d) creates a hardware configuration with\n`s` camera, lens with a focal length `f` and aperture `d` and using wavelenght\n`λ`.\n\nExample\n\nconf1 = hwConfig(\"UI1540\", 300mm, 633nm,25mm) creates a configuration\nbased on UI-1540 camera, with a 1 inch lens with focal length 300mm and He-Ne laser.\n\n\n\n\n\n","category":"method"},{"location":"#AlternatingProjections.AbstractProblems.solve-Tuple{PRproblem, GSparam, Vararg{Any, 5}}","page":"Home","title":"AlternatingProjections.AbstractProblems.solve","text":"solve(pr::PRproblem, alg::GS, args...)\n\nSolve PR problem using GS method. Any change of the GS parameters can be given \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.SHdiversity","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(size, cellsize, celloffset=0, α=0)\n\nGenerate SH diversity phase of given overall size, cellsize, central cell offset and rotation angle α. \n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.SHdiversity-Tuple{AbstractRange, AbstractRange, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(xrange, yrange, e₁, e₂, o)\n\nGenerate SH diversity phase on array xrange × yrange with cell based on orthogonal grid formed by vectors  e₁, e₂, and origin at o. \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.appsftoPR-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.appsftoPR","text":"appsftoPR(ap,psfimage) constructs a phase retrieval problem from two real arrays, representing the pupil and the focal planes intensity distributions. \n\nThe aperture and PSF are assumed to be centred in the array.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\npsfimage = psf(ap);\n\npr = appsftoPR(ap,psfimage)\n\n# output\nPRproblem{Float64, 2}([1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 4.432323038895129 0.7324956483358351 … 4.432323038895129 6.182768610120748; … ; 8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 10.878351222990858 6.182768610120747 … 10.878351222990858 12.999999999999998])\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.binning-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.binning","text":"binning(arr, Q)\n\nDownsample  array by replacing quadratic cells of size Q × Q by summ of its elements\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.centre-NTuple{5, Any}","page":"Home","title":"PhaseRetrieval.centre","text":"Give centre of an orthogonal grid cell of the grid with cellsize, \ncentre at grid origin and rotated at angle α counterclockwise.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.constructSHPhaseDiversity-Tuple{PhaseRetrieval.SHSensor, Any, Any}","page":"Home","title":"PhaseRetrieval.constructSHPhaseDiversity","text":"constructSHPhaseDiversity(wfs::SHSensor, d, λ )\n\nConstruct SH phase diversity of minimal size for wfs within aperture of diameter d and wavelength λ. Return tuple of arrays for the aperture and phase.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diaphragm-Tuple{ImagingLens, Float64}","page":"Home","title":"PhaseRetrieval.diaphragm","text":"diaphragm(lens, diam)\n\nChange the lens diameter of an ImagingLens or an ImagingSensor.\n\nDiaphragm can be larger than the lens diameter (there is no \"hardware limitation\").\n\nExample\n\njulia> diaphragm(ImagingLens(300mm, 25mm), 10mm)\nImagingLens(0.3, 0.01)\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diskmatrix","page":"Home","title":"PhaseRetrieval.diskmatrix","text":"Create array of zeroes with disk of ones of the relative diameter r\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.getstoragetype-Tuple{CameraChip}","page":"Home","title":"PhaseRetrieval.getstoragetype","text":"getstoragetype(cam::CameraChip)\n\nGet the storage type returned by the camera cam.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.intensity-Tuple{Any}","page":"Home","title":"PhaseRetrieval.intensity","text":"intensity(field)\n\nCalculate intensity of the field.\n\nExamples\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\n\njulia> imf = PhaseRetrieval.toimageplane(ap);\n\njulia> PhaseRetrieval.intensity(imf) .|> round\n11×11 Matrix{Float64}:\n 18.0  3.0   1.0   2.0    0.0    1.0    0.0   2.0   1.0  3.0  18.0\n  3.0  0.0   6.0   5.0    0.0    1.0    0.0   5.0   6.0  0.0   3.0\n  1.0  6.0  11.0   4.0    1.0    5.0    1.0   4.0  11.0  6.0   1.0\n  2.0  5.0   4.0   1.0   20.0   38.0   20.0   1.0   4.0  5.0   2.0\n  0.0  0.0   1.0  20.0   78.0  118.0   78.0  20.0   1.0  0.0   0.0\n  1.0  1.0   5.0  38.0  118.0  169.0  118.0  38.0   5.0  1.0   1.0\n  0.0  0.0   1.0  20.0   78.0  118.0   78.0  20.0   1.0  0.0   0.0\n  2.0  5.0   4.0   1.0   20.0   38.0   20.0   1.0   4.0  5.0   2.0\n  1.0  6.0  11.0   4.0    1.0    5.0    1.0   4.0  11.0  6.0   1.0\n  3.0  0.0   6.0   5.0    0.0    1.0    0.0   5.0   6.0  0.0   3.0\n 18.0  3.0   1.0   2.0    0.0    1.0    0.0   2.0   1.0  3.0  18.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.lineararray","page":"Home","title":"PhaseRetrieval.lineararray","text":"lineararray(xrange, yrange, kx, ky, k0=0)\n\nEvaluate values of linear function kxx + kyy + k0  on array  xrange  yrange.\n\nlineararray(size, kx, ky, k0=0)\n\nUse 1:size as xrange and yrange.\n\nlineararray(xrange, yrange, a::Vector, k0=0)\n\nUse first and second components of vector a as kx and ky.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.logrescale","page":"Home","title":"PhaseRetrieval.logrescale","text":"logrescale(array, α = 5)\n\nRescale in log-scale: maximum will correspond to 1, 10^-α will correspond to 0.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.orthIndexes","page":"Home","title":"PhaseRetrieval.orthIndexes","text":"Generate array of indexes of an orthogonal geometry\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.phwrap-Tuple{AbstractFloat}","page":"Home","title":"PhaseRetrieval.phwrap","text":"Wrap Phase\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.psf-Tuple{AbstractArray}","page":"Home","title":"PhaseRetrieval.psf","text":"psf(amplitude, phase) -> psfimage\npsf(pupilfield) -> psfimage\n\nCalculate psf for given amplitude and phase. Both PSF and pupil arrays are assumed     to have the origin in their center pixel ((N+1)÷2 for dimension size N).\n\nExamples\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8); ap\n11×11 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> Int.(round.(psf(ap)))\n11×11 Matrix{Int64}:\n 18  3   1   2    0    1    0   2   1  3  18\n  3  0   6   5    0    1    0   5   6  0   3\n  1  6  11   4    1    5    1   4  11  6   1\n  2  5   4   1   20   38   20   1   4  5   2\n  0  0   1  20   78  118   78  20   1  0   0\n  1  1   5  38  118  169  118  38   5  1   1\n  0  0   1  20   78  118   78  20   1  0   0\n  2  5   4   1   20   38   20   1   4  5   2\n  1  6  11   4    1    5    1   4  11  6   1\n  3  0   6   5    0    1    0   5   6  0   3\n 18  3   1   2    0    1    0   2   1  3  18\n\n\njulia> psf(ones(3,3),zeros(3,3))\n3×3 Matrix{Float64}:\n 0.0   0.0  0.0\n 0.0  81.0  0.0\n 0.0   0.0  0.0\n \njulia> psf(ones(Complex{Float64},4,4))\n4×4 Matrix{Float64}:\n 0.0  0.0    0.0  0.0\n 0.0  0.0    0.0  0.0\n 0.0  0.0  256.0  0.0\n 0.0  0.0    0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.quadratic-Tuple{Tuple}","page":"Home","title":"PhaseRetrieval.quadratic","text":"Generate quadratic array\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale","text":"rescale(array)\n\nRescale array between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale_minmax-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale_minmax","text":"rescale_minmax(array)\n\nRescale array between 0 and 1 and return the rescaled array and the min, max values\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.roi-Tuple{CameraChip, Tuple{Int64, Int64}}","page":"Home","title":"PhaseRetrieval.roi","text":"roi(cam, dims)\n\nCreate camera that represents centered regeion of interest (ROI) of cam.\n\nROI can be larger than the camera size! :-)\n\nArguments\n\ncam: camera (CameraChip) or imaging sensor (ImagingSensor)\ndims::Tuple{Int, Int}: new (width, height) of the image.   Single number defines a square ROI.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.slopearray","page":"Home","title":"PhaseRetrieval.slopearray","text":"slopearray(dom::CartesianDomain2D, dx, dy, k0=0) generates linear array defined on the domain such that\nthe total growth in x and y direction is dx and dy.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.subdivide-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide","text":"subdivide(arr, Q)\n\nSubdivide array of dimension MQ x NQ in Q^2 stacked tiles of size M x N.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.subdivide_sum-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide_sum","text":"subdivide_sum(arr,Q)\n\nDivide array in quadratic cells of size Q × Q  and sum the elements with the same indexes in each cell.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.tile-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.tile","text":"tile(arr, Q)\n\nDivide array in quadratic cells of size Q × Q and stack them along the third dimension.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.toimageplane-Tuple{Any, PhaseRetrieval.Fourier}","page":"Home","title":"PhaseRetrieval.toimageplane","text":"toimageplane(field [, method = Fourier()])\n\nCalculate the field in the focal plane from the field in the pupil plane using method.\n\nAvailable methods:\n\nFourier()\nChirpZ  – not implemented\nMVM – not implemented\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Gonsalves.jl\"","category":"page"},{"location":"tutorials/Gonsalves/#Method-of-Gonsalves-for-small-phases","page":"Gonsalves's method","title":"Method of Gonsalves for small phases","text":"","category":"section"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"This page was generated using Literate.jl.","category":"page"}]
}
