var documenterSearchIndex = {"docs":
[{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/GettingStarted.jl\"","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/GettingStarted/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The goal of this package is to provide tools for the forward and inverse problems of the Phase Retrieval (PR). The examples below show how to set up a simulation environment and how to form a PR problem from given measured PSF and an aperture.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Pages = [\n    \"GettingStarted.md\",\n]\nDepth = 2","category":"page"},{"location":"tutorials/GettingStarted/#tutorial-forward","page":"Getting Started","title":"Forward model","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For the PR problem, the forward model is a simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Let's set up a simulation environment matching the following hardware setup: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length, and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhaseRetrieval\nlens = ImagingLens(300mm, 25mm)\ncam = CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\nims = ImagingSensor(lens=lens, cam=cam)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This creates an aperture array of correct dimensions which is suitable for the generation of a PSF using Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p = psf(conf1.ap)\nusing CairoMakie # hide\nCairoMakie.activate!(; type=\"png\") # hide\nheatmap(rotr90(p[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"print(\"Airy size is 1.22λ/NA = \", 1.22 * 632nm * conf1.f / conf1.d / um, \" μm\")","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"lens2 = PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2.ap)\nheatmap(rotr90(p2[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/GettingStarted/#Faster-creation-of-an-ImagingSensor","page":"Getting Started","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"keys(camerasdict)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"So the imaging sensor can be created as","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ims = ImagingSensor(; cam=cam = camerasdict[\"UI1240\"], lens=lensesdict[\"F300A25\"])","category":"page"},{"location":"tutorials/GettingStarted/#SimConfig","page":"Getting Started","title":"SimConfig","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"SimConfig contains the necessary information for simulations.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"fieldnames(typeof(conf2))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For instance, it contains the aperture mask.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhasePlots\nshowarray(conf2.ap)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in dualroi field and can be used to construct the Zernike basis.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"conf2.dualroi","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This can be used to create the Zernike basis","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhaseBases\nbasis = ZernikeBW(conf2.dualroi, conf2.d, 10);\nshowphase(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Or the same picture without unnecessary information (by default all phases will be shown scaled to (-π. π])","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showphasetight(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"phase = compose(basis, [4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π)\nfig = Figure();\nshowphasetight(phase .* conf2.mask, fig)\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For this aberrated phase the PSF is larger","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p2 = psf(conf2.ap, phase)\nshowarray(p2, :grays)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"More details are visible in the logarithmic scale","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showarray(PhaseRetrieval.logrescale(p))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The SimConfigtype is callable and, if applied to an array of proper dimensions, generates a psf","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p2 = conf2(phase)\nshowarray(p2, :grays)","category":"page"},{"location":"tutorials/GettingStarted/#tutorial-inverse","page":"Getting Started","title":"Inverse problem","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The goal of the inverse problem is from the given PSF and SimConfig to restore the unknown phase.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"As at this stage the problem is already reduced to its numerical equivalent","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using FFTW\nusing AlternatingProjections","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"pr = PRproblem(conf2.ap, p)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"a = fftshift(sqrt.(Float64.(conf2.ap)))\nA = fftshift(sqrt.(collect(Float64, p2)))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, ), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This doesn't work at the moment.  It might work if we let it iterate further","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit =1500), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask); current_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: Output after 1500 iterations)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The phase is perfectly reconstructed now, and  so here is the main problem of the AP-based PR algorithms –- they require quite  a long time to converge, even for the noiseless data.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Let's try to have a smaller crop","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"center = [size(p2)...].÷2\ncrophw=64\npcrop = p2[CartesianIndex(center...) - CartesianIndex(crophw, crophw):CartesianIndex(center...) + CartesianIndex(crophw-1, crophw-1)]\nshowarray(pcrop)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Construct the corresponding sim config and see how it works TODO wrap all this in functions","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ims2crop = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=PhaseRetrieval.roi(cam, 2crophw))\nconf2crop = SimConfig(\"10mm aperture\", ims2crop, 633nm)\na = fftshift(sqrt.(Float64.(conf2crop.ap)))\nA = fftshift(sqrt.(collect(Float64, pcrop )))\nN = sqrt(sum(abs2, A))\nn = sqrt(sum(abs2, a))\nA = A ./ N .* n\npr = TwoSetsFP(\n                ConstrainedByAmplitude(a), FourierTransformedSet(ConstrainedByShape(A))\n            )\nsol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit=450), APparam(maxit = 10)))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true), APparam(maxϵ = 0.001)))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask); current_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"You can try to change slightly the values of β above and see that algorithm might converge to another solution. This is another problem of AP-based algorithms.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Inverse/#Inverse-problem","page":"Introduction","title":"Inverse problem","text":"","category":"section"},{"location":"Inverse/","page":"Introduction","title":"Introduction","text":"The goal of the inverse problem in Phase Retrieval is to reconstruct the phase of the field  in the pupil field from the intensity measurements in the focal plane.","category":"page"},{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package is devoted to the forward and inverse problems of Phase Retrieval (PR).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Hardware.jl\"","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/Hardware/#Hardware-types","page":"Forward model","title":"Hardware types","text":"","category":"section"},{"location":"tutorials/Hardware/#Camera-chip","page":"Forward model","title":"Camera chip","text":"","category":"section"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"CameraChip represents a device that outputs sampled field intensity quantized and packed in 8- or 16-bit integer per color channel (currently, only monochrome cameras are implemented).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This code sets up a camera with 5.2μm pixel, 1280 × 1024 frame, bitdepth and channeldepth  of 8 bits:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"using PhaseRetrieval\nusing PhasePlots\nusing CairoMakie\nusing ImageCore\ncam = CameraChip(;\n    pixelsize=5.2um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Cameras can be also created using camerasdict dictionary. Let's consider examples of 8-bit and 12-bit cameras:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam8bit = camerasdict[\"UI1240\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"and","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam12bit = camerasdict[\"UI3860\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"and compare the results of using these two cameras to measure this  field created by a circular aperture:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"ap,_ = PhaseRetrieval.aperture(-1:.025:1,-1:.025:1,0.9)\n\nshowarray(ap)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The field itself is represented by a complex array, which has this amplitude and phase (we can see that due to the aperture symmetry, the field in the focal plane is real, actually, and the phase take only values 0 and π):","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"imf = PhaseRetrieval.toimageplane(ap)\nshowarray(abs.(imf)) |> display\nshowphasetight(angle.(imf)); current_figure()","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"And now we can quantize this field by our 8-bit and 12-bit example cameras","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam8bit(imf) |> collect","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam12bit(imf) |> collect","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"note: Note\nWe have used collect here, as CameraChip returns a mapped view of the field.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We can see that for our 12-bit camera, the measurements are represented by the last 12 bits of a 16-bit number (N4f12).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We can hardly see the difference in the camera outputs. Compare 8bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam8bit(imf) .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"with 12 bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam12bit(imf) .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The difference is visible in the logarithmic scale. compare 8bit:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam8bit(imf) .|> float |> PhaseRetrieval.logrescale .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"and 12 bit","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam12bit(imf) .|> float |> PhaseRetrieval.logrescale .|> Gray","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"note: Note\nHere we have used already sampled optical filed imf, so there is no difference in the sampling rate performed by the cameras. This effect will be demonstrated in the next example.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"#PhaseRetrieval.jl-Documentation","page":"Home","title":"PhaseRetrieval.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\nPages = [\n        \"index.md\",\n        \"about.md\",\n        \"tutorials/GettingStarted.md\",\n        \"tutorials/Hardware.md\",  \n        \"Inverse.md\", \n        \"tutorials/Gonsalves.md\",                \n        \"tutorials/AP.md\",\n    ]\nDepth = 3","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseRetrieval]\nPrivate = false","category":"page"},{"location":"#PhaseRetrieval.camerasdict","page":"Home","title":"PhaseRetrieval.camerasdict","text":"`camerasdict` is a dictionary with often used cameras.\n\nUse keys(camerasdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.lensesdict","page":"Home","title":"PhaseRetrieval.lensesdict","text":"`lensesdict` is a dictionary with often used cameras.\n\nUse keys(lensesdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.AbstractPRproblem","page":"Home","title":"PhaseRetrieval.AbstractPRproblem","text":"Big class of general phase-retrieval-related problems.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip","page":"Home","title":"PhaseRetrieval.CameraChip","text":"CameraChip(pixelsize, imagesize; <keyword args>)\n\nCreate a camera chip with a given square pixel size and image size.\n\nYou can also specify the bit depth of the camera and the channel bit depth. For instance, 12-bit camera (bitdepth =12) often transfer its measurement packed in 16-bit number (channelbitdepth = 16).\n\nIf called on a complex field, output the image seen by the chip.\n\nSee also camerasdict, storagetype, intensity.\n\nArguments\n\npixelsize::Float64: size of the pixel. Only square pixels are supported.\nimagesize::Tuple{Int, Int}: (width, height) of the image.\nbitdepth::Int = 8: bit detpth of the camera.\nchannelbitdepth::Int = 8: channel bit depth of the camera. \n\nArguments can be specified in any order.\n\nExample\n\ncam = CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.25:1,-1:.25:1,.8); ap\n9×9 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> imf = PhaseRetrieval.toimageplane(ap);\n\njulia> cam = camerasdict[\"UI3860\"];\n\njulia> cam(imf, AutoExposure(.7)) |> collect\n9×9 Array{N4f12,2} with eltype FixedPointNumbers.N4f12:\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0601  0.0  0.1411  0.4987  0.6999  0.4987  0.1411  0.0  0.0601\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GS","page":"Home","title":"PhaseRetrieval.GS","text":"Gerchberg-Saxton, classical method to solve PR problem\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GSparam","page":"Home","title":"PhaseRetrieval.GSparam","text":"GSparam(; ϕ⁰, maxit, maxϵ, keephistory, snapshots)\n\nParameters for a concrete realisation of GS method.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingLens","page":"Home","title":"PhaseRetrieval.ImagingLens","text":"ImagingLens(;focallength, aperture)\n\nCreate fixed focal length lens with focus = focallength and aperture dimater aperture.\n\nArguments can be speciefied in any order.\n\nSee also diaphragm, lensesdict.\n\nExample\n\njulia> lens = ImagingLens(300mm, 25mm)\nImagingLens(0.3, 0.025)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingSensor","page":"Home","title":"PhaseRetrieval.ImagingSensor","text":"ImagingSensor(lens=lens, cam=cam)\n\nImaging sensor or camera consisting of a lens lens and camera chip cam.\n\nCreate a sensor using keyword syntaxis (in any order), lens and cam are required\n\nims = ImagingSensor(lens = ::ImagingLens, cam = ::CameraChip)\n\nSee also roi, diaphragm.\n\nArguments:\n\nlens::ImagingLens: lens of the camera\ncam::CameraChip: sensor chip of the camera\n\nIf lens and cam are strings, corresponding values from lensesdict and camerasdict are used.\n\nOther possible keywords to simulate misalingnment (not implemented yet)\n\nfocal_distance = lens.focallength: Distance between the lens and the sensor.\nlensorigin = [0.,0.]: nodal point, expressed in length units (mm or um)\nChip plane misalingment angles: \nα = 0: rotation in x\nβ = 0: rotation in y\nγ = 0: rotation in z\n\nExample\n\njulia> ImagingSensor(lens = ImagingLens(300mm, 25mm),\n           cam = CameraChip(\n               pixelsize=5.2um,\n               imagesize=(1280, 1024),\n               bitdepth=8,\n               channelbitdepth=8\n               )\n           )\nImagingSensor(ImagingLens(0.3, 0.025), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n \njulia> diaphragm(ImagingSensor(lens = lensesdict[\"F300A25\"], cam= camerasdict[\"UI1540\"]), 10mm)\nImagingSensor(ImagingLens(0.3, 0.01), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n \njulia> ImagingSensor(\"F300A25\",  \"UI1540\")\nImagingSensor(ImagingLens(0.3, 0.025), CameraChip(5.2e-6, (1280, 1024), 8, 8), 0.3, (0.0, 0.0), 0.0, 0.0, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblem","page":"Home","title":"PhaseRetrieval.PRproblem","text":"PRproblem(a, A)\n\nClassical phase-retrieval problem of finding complex arrays x, X such that    |x| = a, |X| = A, and X =F(x),  where F denotes the Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SimConfig","page":"Home","title":"PhaseRetrieval.SimConfig","text":"SimConfig(name::String, ims::PhaseRetrieval.ImagingSensor, λ::Float64) creates forward-model \nsimulation environment for the PR problem obtained with  `ims` image sensor (camera + lens) at \n    wavelength `λ`. `name` is a sting identifacator used for, for instace, plotting labels.\n\nSimConfig contains the following fields:     julia     name::String     ims::PhaseRetrieval.ImagingSensor     f::Float64     λ::Float64     d::Float64     q::Int     roi::CartesianDomain2D     dualroi::CartesianDomain2D     ap::Array{Float64,2}     mask::Array{Float64,2}`\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.hwConfig-Tuple{String, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.hwConfig","text":"hwConfig(s::String, f, λ, d) creates a hardware configuration with\n`s` camera, lens with a focal length `f` and aperture `d` and using wavelenght\n`λ`.\n\nExample\n\nconf1 = hwConfig(\"UI1540\", 300mm, 633nm,25mm) creates a configuration\nbased on UI-1540 camera, with a 1 inch lens with focal length 300mm and He-Ne laser.\n\n\n\n\n\n","category":"method"},{"location":"#AlternatingProjections.AbstractProblems.solve-Tuple{PRproblem, GSparam, Vararg{Any, 5}}","page":"Home","title":"AlternatingProjections.AbstractProblems.solve","text":"solve(pr::PRproblem, alg::GS, args...)\n\nSolve PR problem using GS method. Any change of the GS parameters can be given \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.SHdiversity","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(size, cellsize, celloffset=0, α=0)\n\nGenerate SH diversity phase of given overall size, cellsize, central cell offset and rotation angle α. \n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.SHdiversity-Tuple{AbstractRange, AbstractRange, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(xrange, yrange, e₁, e₂, o)\n\nGenerate SH diversity phase on array xrange × yrange with cell based on orthogonal grid formed by vectors  e₁, e₂, and origin at o. \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.appsftoPR-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.appsftoPR","text":"appsftoPR(ap,psfimage) constructs a phase retrieval problem from two real arrays, representing the pupil and the focal planes intensity distributions. \n\nThe aperture and PSF are assumed to be centred in the array.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\npsfimage = psf(ap);\n\npr = appsftoPR(ap,psfimage)\n\n# output\nPRproblem{Float64, 2}([1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 4.432323038895129 0.7324956483358351 … 4.432323038895129 6.182768610120748; … ; 8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 10.878351222990858 6.182768610120747 … 10.878351222990858 12.999999999999998])\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diaphragm-Tuple{ImagingLens, Float64}","page":"Home","title":"PhaseRetrieval.diaphragm","text":"diaphragm(lens, diam)\n\nChange the lens diameter of an ImagingLens or an ImagingSensor.\n\nDiaphragm can be larger than the lens diameter (there is no \"hardware limitation\").\n\nExample\n\njulia> diaphragm(ImagingLens(300mm, 25mm), 10mm)\nImagingLens(0.3, 0.01)\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.phwrap-Tuple{AbstractFloat}","page":"Home","title":"PhaseRetrieval.phwrap","text":"Wrap Phase\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.psf-Tuple{AbstractArray}","page":"Home","title":"PhaseRetrieval.psf","text":"psf(amplitude, phase) -> psfimage\npsf(pupilfield) -> psfimage\n\nCalculate psf for given amplitude and phase. Both PSF and pupil arrays are assumed     to have the origin in their center pixel ((N+1)÷2 for dimension size N).\n\nExamples\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8); ap\n11×11 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> Int.(round.(psf(ap)))\n11×11 Matrix{Int64}:\n 18  3   1   2    0    1    0   2   1  3  18\n  3  0   6   5    0    1    0   5   6  0   3\n  1  6  11   4    1    5    1   4  11  6   1\n  2  5   4   1   20   38   20   1   4  5   2\n  0  0   1  20   78  118   78  20   1  0   0\n  1  1   5  38  118  169  118  38   5  1   1\n  0  0   1  20   78  118   78  20   1  0   0\n  2  5   4   1   20   38   20   1   4  5   2\n  1  6  11   4    1    5    1   4  11  6   1\n  3  0   6   5    0    1    0   5   6  0   3\n 18  3   1   2    0    1    0   2   1  3  18\n\n\njulia> psf(ones(3,3),zeros(3,3))\n3×3 Matrix{Float64}:\n 0.0   0.0  0.0\n 0.0  81.0  0.0\n 0.0   0.0  0.0\n \njulia> psf(ones(Complex{Float64},4,4))\n4×4 Matrix{Float64}:\n 0.0  0.0    0.0  0.0\n 0.0  0.0    0.0  0.0\n 0.0  0.0  256.0  0.0\n 0.0  0.0    0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.roi-Tuple{CameraChip, Tuple{Int64, Int64}}","page":"Home","title":"PhaseRetrieval.roi","text":"roi(cam, dims)\n\nCreate camera that represents centered regeion of interest (ROI) of cam.\n\nROI can be larger than the camera size! :-)\n\nArguments\n\ncam: camera (CameraChip) or imaging sensor (ImagingSensor)\ndims::Tuple{Int, Int}: new (width, height) of the image.   Single number defines a square ROI.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/AP.jl\"","category":"page"},{"location":"tutorials/AP/#Alternative-projections-based-methods","page":"AP-based methods","title":"Alternative-projections-based methods","text":"","category":"section"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"","category":"page"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"EditURL = \"https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Gonsalves.jl\"","category":"page"},{"location":"tutorials/Gonsalves/#Method-of-Gonsalves-for-small-phases","page":"Gonsalves's method","title":"Method of Gonsalves for small phases","text":"","category":"section"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"This page was generated using Literate.jl.","category":"page"}]
}
