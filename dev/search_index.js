var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"#PhaseRetrieval.jl-Documentation","page":"Home","title":"PhaseRetrieval.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#About-the-package","page":"Home","title":"About the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is devoted to the forward and inverse problems of Phase Retrieval (PR).","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"#Forward-model","page":"Home","title":"Forward model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the PR problem, forward model is simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's set up a simulation environment matching the following hardware set up: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PhaseRetrieval\nlens = PhaseRetrieval.ImagingLens(300mm, 25mm)\ncam = PhaseRetrieval.CameraChip(pixelsize = 5.3um, imagesize = (1280, 1024), bitdepth = 8, channelbitdepth = 8)\nims = PhaseRetrieval.ImagingSensor(lens = lens, cam = cam)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This creates aperture array of correct dimensions which is suitable for generation of a PSF using Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = psf(conf1.ap)\nusing CairoMakie # hide\nCairoMakie.activate!(type = \"png\") # hide\nheatmap(rotr90(p[503:523,631:651]), axis = (aspect = DataAspect(), ))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"","page":"Home","title":"Home","text":"print(\"Airy size is 1.22λ/NA = \",  1.22*632nm *conf1.f/conf1.d /um, \" μm\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lens2= PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(lens = lens2, cam = cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2.ap)\nheatmap(rotr90(p2[503:523,631:651]), axis = (aspect = DataAspect(), ))","category":"page"},{"location":"#Faster-creation-of-an-ImagingSensor","page":"Home","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"","page":"Home","title":"Home","text":"keys(camerasdict)","category":"page"},{"location":"","page":"Home","title":"Home","text":"So the imaging sensor can be created as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ims = ImagingSensor(cam = cam = camerasdict[\"UI1240\"], lens = lensesdict[\"F300A25\"])","category":"page"},{"location":"#SimConfig","page":"Home","title":"SimConfig","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SimConfig contains necessary information for simulations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fieldnames(typeof(conf2))","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, it contains the aperture mask.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PhasePlots\nshowarray(conf2.ap)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in dualroi field and can be used to construct the Zernike basis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"conf2.dualroi","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PhaseBases\nbasis = ZernikeBW(conf2.dualroi, conf2.d, 10);\nshowphase(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or the same picture without unnecssary information (by default all phases will be shown scaled to (-π. π])","category":"page"},{"location":"","page":"Home","title":"Home","text":"showphasetight(basis.elements[15] .* conf2.mask)\ncurrent_figure()","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"","page":"Home","title":"Home","text":"phase = compose(basis, [4, 6, 15,16], [2, 1, 0.4, 0.3]*2π)\nfig= Figure();\nshowphasetight(phase .* conf2.mask, fig)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this aberrated phase the PSF is larger","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = psf(conf2.ap, phase)\nshowarray(p, :grays)","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details are visible in the logarithmic scale","category":"page"},{"location":"","page":"Home","title":"Home","text":"showarray(PhaseRetrieval.logrescale(p))","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseRetrieval]","category":"page"},{"location":"#PhaseRetrieval.camerasdict","page":"Home","title":"PhaseRetrieval.camerasdict","text":"`camerasdict` is a dictionary with often used cameras.\n\nUse keys(camerasdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.lensesdict","page":"Home","title":"PhaseRetrieval.lensesdict","text":"`lensesdict` is a dictionary with often used cameras.\n\nUse keys(lensesdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.AbstractPRproblem","page":"Home","title":"PhaseRetrieval.AbstractPRproblem","text":"Big class of general phase-retrieval-related problems.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip","page":"Home","title":"PhaseRetrieval.CameraChip","text":"CameraChip(pixelsize = p, imagesize = (sizex, sizey), bitdepth = 8, channelbitdepth = 8 repesent a camera chip with a given pixel size, imagesize, and bitdepth. If omitted,  bitdepth is set to 8.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GS","page":"Home","title":"PhaseRetrieval.GS","text":"Gerchberg-Saxton, classical method to solve PR problem\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GSparam","page":"Home","title":"PhaseRetrieval.GSparam","text":"GSparam(; ϕ⁰, maxit, maxϵ, keephistory, snapshots)\n\nParameters for a concrete realisation of GS method.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingLens","page":"Home","title":"PhaseRetrieval.ImagingLens","text":"Fixed focal length lens\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingSensor","page":"Home","title":"PhaseRetrieval.ImagingSensor","text":"Imaging sensor or camera consists of a lens and camera chip.\n\nCreate a sensor using keyword syntaxis (in any order), lens and cam are required\n\nims = ImagingSensor(lens = ::ImagingLens, cam = ::CameraChip)\n\nOther possible keywords to simulate misalingnment\n\n    focal_distance (= lens.focallength  by default)\n    lensorigin = [0.,0.] # aka nodal point, but expressed in length units\n    # misalingment parameters (not realised yet, set to zero)\n    α = 0.\n    β = 0.\n    γ = 0.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Linear","page":"Home","title":"PhaseRetrieval.Linear","text":"Build SH diversity using the linear functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.MLA","page":"Home","title":"PhaseRetrieval.MLA","text":"Micro-lens array structure. \n\nThe main reason to introduce it separable is to handle the case when camera chip is located not exactly\nin the MLA focal plane.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PDplan","page":"Home","title":"PhaseRetrieval.PDplan","text":"PDplan(plan, diversity)\n\nConstruct Pupil Diversity plan, which, if multiplied by the array a of proper dimensions, computes fft( diversity *a)\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblem","page":"Home","title":"PhaseRetrieval.PRproblem","text":"PRproblem(a, A)\n\nClassical phase-retrieval problem of finding complex arrays x, X such that    |x| = a, |X| = A, and X =F(x),  where F denotes the Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.Quadratic","page":"Home","title":"PhaseRetrieval.Quadratic","text":"Build SH diversity using the quadratic functions\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SHSensor","page":"Home","title":"PhaseRetrieval.SHSensor","text":"Shack-Hartmann sensor composed from MLA and a camera. \n\nMLA plane position is defined by distance,  β,  and γ. \nMLA subapertures position is defined by mlaorigin and α.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SimConfig","page":"Home","title":"PhaseRetrieval.SimConfig","text":"SimConfig(name::String, ims::PhaseRetrieval.ImagingSensor, λ::Float64) creates forward-model \nsimulation environment for the PR problem obtained with  `ims` image sensor (camera + lens) at \n    wavelength `λ`. `name` is a sting identifacator used for, for instace, plotting labels.\n\nSimConfig contains the following fields:     julia     name::String     ims::PhaseRetrieval.ImagingSensor     f::Float64     λ::Float64     d::Float64     q::Int     roi::CartesianDomain2D     dualroi::CartesianDomain2D     ap::Array{Float64,2}     mask::Array{Float64,2}`\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.hwConfig-Tuple{String, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.hwConfig","text":"hwConfig(s::String, f, λ, d) creates a hardware configuration with\n`s` camera, lens with a focal length `f` and aperture `d` and using wavelenght\n`λ`.\n\nExample\n\nconf1 = hwConfig(\"UI1540\", 300mm, 633nm,25mm) creates a configuration\nbased on UI-1540 camera, with a 1 inch lens with focal length 300mm and He-Ne laser.\n\n\n\n\n\n","category":"method"},{"location":"#AlternatingProjections.AbstractProblems.solve-Tuple{PRproblem, GSparam, Vararg{Any, 5}}","page":"Home","title":"AlternatingProjections.AbstractProblems.solve","text":"solve(pr::PRproblem, alg::GS, args...)\n\nSolve PR problem using GS method. Any change of the GS parameters can be given \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.SHdiversity","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(size, cellsize, celloffset=0, α=0)\n\nGenerate SH diversity phase of given overall size, cellsize, central cell offset and rotation angle α. \n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.SHdiversity-Tuple{AbstractRange, AbstractRange, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(xrange, yrange, e₁, e₂, o)\n\nGenerate SH diversity phase on array xrange × yrange with cell based on orthogonal grid formed by vectors  e₁, e₂, and origin at o. \n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.appsftoPR-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.appsftoPR","text":"appsftoPR(ap,psfimage) constructs a phase retrieval problem from two real arrays, representing the pupil and the focal planes intensity distributions. \n\nThe aperture and PSF are assumed to be centred in the array.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\npsfimage = psf(ap);\n\npr = appsftoPR(ap,psfimage)\n\n# output\nPRproblem{Float64, 2}([1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 4.432323038895129 0.7324956483358351 … 4.432323038895129 6.182768610120748; … ; 8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 10.878351222990858 6.182768610120747 … 10.878351222990858 12.999999999999998])\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.binning-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.binning","text":"binning(arr, Q)\n\nDownsample  array by replacing quadratic cells of size Q × Q by summ of its elements\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.centre-NTuple{5, Any}","page":"Home","title":"PhaseRetrieval.centre","text":"Give centre of an orthogonal grid cell of the grid with cellsize, \ncentre at grid origin and rotated at angle α counterclockwise.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.constructSHPhaseDiversity-Tuple{PhaseRetrieval.SHSensor, Any, Any}","page":"Home","title":"PhaseRetrieval.constructSHPhaseDiversity","text":"constructSHPhaseDiversity(wfs::SHSensor, d, λ )\n\nConstruct SH phase diversity of minimal size for wfs within aperture of diameter d and wavelength λ. Return tuple of arrays for the aperture and phase.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diskmatrix","page":"Home","title":"PhaseRetrieval.diskmatrix","text":"Create array of zeroes with disk of ones of the relative diameter r\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.lineararray","page":"Home","title":"PhaseRetrieval.lineararray","text":"lineararray(xrange, yrange, kx, ky, k0=0)\n\nEvaluate values of linear function kxx + kyy + k0  on array  xrange  yrange.\n\nlineararray(size, kx, ky, k0=0)\n\nUse 1:size as xrange and yrange.\n\nlineararray(xrange, yrange, a::Vector, k0=0)\n\nUse first and second components of vector a as kx and ky.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.logrescale","page":"Home","title":"PhaseRetrieval.logrescale","text":"logrescale(array, α = 5)\n\nRescale in log-scale: maximum will correspond to 1, 10^-α will correspond to 0.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.orthIndexes","page":"Home","title":"PhaseRetrieval.orthIndexes","text":"Generate array of indexes of an orthogonal geometry\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.phwrap-Tuple{AbstractFloat}","page":"Home","title":"PhaseRetrieval.phwrap","text":"Wrap Phase\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.psf-Tuple{AbstractArray}","page":"Home","title":"PhaseRetrieval.psf","text":"psf(amplitude, phase) -> psfimage psf(pupilfield) -> psfimage\n\nCalculate psf for given amplitude and phase.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\n\npsfimage = psf(ap)\n\npsfimage[1]\n\n# output\n\n17.720305330423212\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.quadratic-Tuple{Tuple}","page":"Home","title":"PhaseRetrieval.quadratic","text":"Generate quadratic array\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale","text":"rescale(array)\n\nRescale array between 0 and 1\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.rescale_minmax-Tuple{Any}","page":"Home","title":"PhaseRetrieval.rescale_minmax","text":"rescale_minmax(array)\n\nRescale array between 0 and 1 and return the rescaled array and the min, max values\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.slopearray","page":"Home","title":"PhaseRetrieval.slopearray","text":"slopearray(dom::CartesianDomain2D, dx, dy, k0=0) generates linear array defined on the domain such that\nthe total growth in x and y direction is dx and dy.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.subdivide-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide","text":"subdivide(arr, Q)\n\nSubdivide array of dimension MQ x NQ in Q^2 stacked tiles of size M x N.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.subdivide_sum-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.subdivide_sum","text":"subdivide_sum(arr,Q)\n\nDivide array in quadratic cells of size Q × Q  and sum the elements with the same indexes in each cell.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.tile-Tuple{Any, Integer}","page":"Home","title":"PhaseRetrieval.tile","text":"tile(arr, Q)\n\nDivide array in quadratic cells of size Q × Q and stack them along the third dimension.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
