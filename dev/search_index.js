var documenterSearchIndex = {"docs":
[{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"../../../tutorials/GettingStarted.jl\"","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/GettingStarted/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The goal of this package is to provide tools for the forward and inverse problems of the Phase Retrieval (PR). The examples below show how to set up a simulation environment and how to form a PR problem from given measured PSF and an aperture.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Pages = [\n    \"GettingStarted.md\",\n]\nDepth = 2","category":"page"},{"location":"tutorials/GettingStarted/#tutorial-forward","page":"Getting Started","title":"Forward model","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For the PR problem, the forward model is a simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.","category":"page"},{"location":"tutorials/GettingStarted/#Initialising-the-simulation","page":"Getting Started","title":"Initialising the simulation","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Let's set up a simulation environment matching the following hardware setup: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length, and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhaseRetrieval\nlens = ImagingLens(300mm, 25mm)\ncam = CameraChip(; pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)\nims = ImagingSensor(; lens=lens, cam=cam)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This creates a simulation configuration for the generation of a PSF using PSFMethods.Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide. To crop central part of the image, we'll use crop function from PhaseUtils package.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p = psf(conf1)\nusing CairoMakie # hide\nCairoMakie.activate!(; type=\"png\") # hide\nusing PhaseUtils\nheatmap(rotr90(crop(p, 9)); axis=(aspect=DataAspect(),)) # show central 9 pixels","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"print(\"Airy size is 1.22λ/NA = $(airysize(conf1)/ um) μm\")","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"lens2 = PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2)\nheatmap(rotr90(crop(p2, 9)); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/GettingStarted/#Faster-creation-of-an-ImagingSensor","page":"Getting Started","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"keys(camerasdict)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"So the imaging sensor can be created as","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ims = ImagingSensor(; cam=camerasdict[\"UI1240\"], lens=lensesdict[\"F300A25\"])","category":"page"},{"location":"tutorials/GettingStarted/#Quantisation-and-exposure-level","page":"Getting Started","title":"Quantisation and exposure level","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"By default, the returned PSF approximates the output of a camera with finite bit resolution (8 bits in our case):","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"eltype(p2)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"One can use Images.jl package to obtain images as saved by the camera: The whole frame:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using ImageCore\nsave(\"psf2.png\", Gray.(p2))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Crop of the central part","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Gray.(crop(p2, 21))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"By default, the returned PSF is called between 0 and 1 (AutoExposure feature). This can be changed by passing additional parameters to psf function. Here is an example of a PSF with 4 times longer exposure:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"psf2_sat4 = psf(conf2; exposure=AutoExposure(4))\nGray.(crop(psf2_sat4, 21))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The same psf in logarithmic scale:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Gray.(logrescale(float.(crop(psf2_sat4, 21))))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"And without quantisation:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"psf2_sat4_float = psf(conf2; exposure=AutoExposure(4), quantize=false)\nGray.(logrescale(crop(psf2_sat4_float, 21)))","category":"page"},{"location":"tutorials/GettingStarted/#Adding-the-phase-aberration","page":"Getting Started","title":"Adding the phase aberration","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now we can add some phase to our configuration. To add a modal phase represented by Zernike polynomials, we need to create the basis first. This creates it for the first 10 radial orders:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhaseBases\nz10 = ZernikeBW(conf2, 10);\nnothing #hide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The basis now contains 60 Zernike polynomials (in Born and Wolf form, normed by rms value), numbered in OSA/ANSI indexes. Elements of basis can be accessed as follows:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"by double indexing:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using PhasePlots\nshowphasetight(z10(; m=10, n=10) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"by single index:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showphasetight(z10(12) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"phase = ModalPhase([4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π, z10)\nshowphasetight(phase .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"To apply this phase to the simulation configuration, apply it literally:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"phase(conf2)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"and check the PSF","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p2 = psf(conf2)\nsave(\"psf2_ab.png\", Gray.(p2));\nnothing #hide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"For this aberrated phase the PSF is larger and more details are visible in the logarithmic scale","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showarray(logrescale(float(p2)))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The SimConfigtype is callable and, if applied to an array of proper dimensions, generates a PSF:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"p2 = conf2(phase)\nshowarray(p2; colormap=:grays)","category":"page"},{"location":"tutorials/GettingStarted/#Adding-some-diversity","page":"Getting Started","title":"Adding some diversity","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This creates a defocus of 1λ/4 amplitude:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"defocus = 2π / 4 * z10(; n=2, m=0)\nshowphase(collect(defocus .* conf2.mask))[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Or we could better create diversities corresponding in the depth-of-focus lengths, which is approximately the same","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"defocus = ZonalPhase(throughfocus(conf2, doflength(conf2)))\nshowphase(collect(-(defocus .+ π / 2) .* conf2.mask))[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"And now we add several diversities to our conf2","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"conf2.diversity = NamedTuple(zip(Symbol.(\"d=\", -2:2), [k * defocus for k in -2:2]))\n\ndiv_psf = diversed_psfs(conf2)\nfor (p, d) in zip(div_psf, collect(keys(conf2.diversity)))\n    fig, ax, hm = showarray(logrescale(float(crop(p, 256))))\n    ax.title = \"PSF # $d\"\n    save(\"psf2_div_fig_$d.png\", fig)\nend","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"tutorials/GettingStarted/#tutorial-inverse","page":"Getting Started","title":"Inverse problem","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The goal of the inverse problem is from the given PSF and SimConfig to restore the unknown phase.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"In mathematics, the (2D) phase retrieval (PR) problem can be described as","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"textfind x mathbbC^M times N textst\nabsx = a absF x = A","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"for some real arrays a and A","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"As for the PSF p one has p = absF (a e^i phi), we can from the PRproblem by passing to PRproblem object two arrays corresponding to the square root of the intensities in the pupil and focal planes. This PR problem we try to solve using successive applications of the DRAP algorithm with β = 0.9 and Alternating projections algorithm with the default number of iterations.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using FFTW\na = sqrt.(Float64.(conf2.ap))\nA = sqrt.(collect(Float64, p2))\npr = PRproblem(a, A)\nsol = solve(pr, (DRAPparam(; β=0.9, keephistory=true), APparam(; maxϵ=0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This doesn't work at the moment.  It might work if we let it iterate further","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit =1500), APparam(maxϵ = 0.001)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: Output after 1500 iterations)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The phase is perfectly reconstructed now, and so here is the main problem of the AP-based PR algorithms –- they require quite a long time to converge, even for the noiseless data.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Here is an attempt with the initial guess given by the simple subset method","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"th = 0.6 * maximum(A)\nxth = copy(A)\nxth[A .> th] .*= 1\nxth[A .<= th] .= 0\nshowarray(xth)\n\nalg = DRAPparam(; x⁰=ifft(xth), β=0.95, keephistory=true, maxit=200)\nsol = solve(pr, (alg, APparam(; maxit=50)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Let's try to have a smaller crop","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"cropw = 128\npcrop = crop(p2, cropw)\nshowarray(pcrop)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Construct the corresponding sim config and see how it works TODO #5 wrap all this in functions","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ims2crop = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=PhaseRetrieval.roi(cam, cropw))\nconf2crop = SimConfig(\"10mm aperture\", ims2crop, 633nm)\na = sqrt.(Float64.(conf2crop.ap))\nA = sqrt.(collect(Float64, pcrop))\npr = PRproblem(a, A)\n@time sol = solve(\n    pr, (DRAPparam(; β=0.9, keephistory=true, maxit=550), APparam(; maxit=10))\n)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true), APparam(maxϵ = 0.001)))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"You can try to change slightly the values of β above and see that algorithm might converge to another solution. This is another problem of AP-based algorithms.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"@time sol = solve(\n    pr, (DRAPparam(; β=0.91, keephistory=true, maxit=550), APparam(; maxit=10))\n)\nshowphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Douglas-Rachford is known to eventually find the solution if you run it long enough: For instance, starting with b=0.9 would require about 20000 iterations to converge:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(; β=0.9, keephistory=true, maxit=20000), APparam(; maxit=100)))\nshowphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Fortunately, julia is fast, so the calculations of 20K iterations take less than a minute.","category":"page"},{"location":"tutorials/GettingStarted/#Using-phase-diversity","page":"Getting Started","title":"Using phase diversity","text":"","category":"section"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"To use phase-diverse Phase Retrieval, we need to construct the phase diversities for the cropped configuration","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"z10 = ZernikeBW(conf2crop, 10);\nnothing #hide","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Then we know, that cropped PSFs correspond to different values of the same defocus","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# defocus = 2π / 4 * z10(; n=2, m=0)\ndefocus = ZonalPhase(throughfocus(conf2crop, doflength(conf2crop)))\nphases = [collect(k * defocus) for k in -2:2] #TODO #3 this should be automatized","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Crop the corresponding PSFs","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"div_psf_crop = crop.(div_psf, cropw)\nsave(\"psf_crop.png\", Gray.(mosaicview(div_psf_crop; nrow=1, npad=5, fillvalue=1)))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now the set corresponding to the pupil phase will be phase-diversed set","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"a = sqrt.(Float64.(conf2crop.ap))\nA = [sqrt.(collect(Float64, p)) for p in div_psf_crop]\npr = PDPRproblem(a, A, phases)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"As expected, using phase diversities accelerates the phase retrieval a lot","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"@time sol = solve(pr, (DRAPparam(; β=0.9, keephistory=true, maxit=50), APparam(; maxit=50)))\nshowphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2crop.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"And now it should be also less sensitive to the parameter choice. But they do affect the speed of the convergence","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = solve(pr, (DRAPparam(; β=0.5, keephistory=true, maxit=50), APparam(; maxit=50)))\nshowphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2crop.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Try to unwrap the phase (we subtract the first diversity)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ph = phwrap(fftshift(angle.(sol[1][:, :, 1])) - phases[1])\nph_u = unwrap_LS(ph, conf2crop.ap)\nfig, ax, hm = showarray(bboxview(ph_u .* conf2crop.mask))\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now the phase is unwrapped and can be decomposed by the basis functions","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"restored_coef = PhaseBases.decompose(ph_u, z10)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"and compare the restored coefficients with the original ones","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"fig = Figure();\nax = Axis(fig[1, 1]);\nscatter!(phase.coef; label=\"original\")\nscatter!(restored_coef; label=\"restored\")\nax.title = \"Original vs restored Zernike coefficients\"\naxislegend()\n\nerr_coef = restored_coef .- phase.coef\nerr_coef[1] = 0\nax, _ = scatter(fig[2, 1], err_coef)\nax.title = \"Coefficient restoration error\"\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The error is quite small, although we see it increasing for high-order aberrations.  We can compare the phases themselves and see the error appearing on the edges.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ph_u .-= restored_coef[1]\nphase_crop = ModalPhase(phase.coef, z10)\nerr = (ph_u .- phase_crop)\nfig, ax, hm = showarray(bboxview(err .* conf2crop.mask))\nColorbar(fig[1, 2], hm)\nax.title = \"Phase restoration error, rms = $(round(maskedrmse(err, z10.ap), digits = 3))\"\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Try with high-res phase","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"z10 = ZernikeBW(conf2, 10);\ndefocus = 2π / 4 * z10(; n=2, m=0)\ndefocus = ZonalPhase(throughfocus(conf2, doflength(conf2)))\nphases = [collect(k * defocus) for k in -2:2] #TODO this should be automatized\n\na = sqrt.(Float64.(conf2.ap))\nA = [sqrt.(collect(Float64, p)) for p in div_psf]\n\npr = PDPRproblem(a, A, phases)\nsol = solve(pr, (DRAPparam(; β=0.5, keephistory=true, maxit=50), APparam(; maxit=50)))\nshowphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2.mask)[1]","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We again unwrap the phase and subtract the first diversity","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ph = phwrap(fftshift(angle.(sol[1][:, :, 1])) - phases[1])\nph_u = unwrap_LS(ph, conf2.ap)\nfig, ax, hm = showarray(bboxview(ph_u .* conf2.mask))\nax.aspect = 1\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Now the phase is unwrapped and can be decomposed by the basis functions","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"restored_coef = PhaseBases.decompose(ph_u, z10)","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"and compare the restored coefficients with the original ones","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"fig = Figure();\nax = Axis(fig[1, 1]);\nscatter!(phase.coef; label=\"original\")\nscatter!(restored_coef; label=\"restored\")\nax.title = \"Original vs restored Zernike coefficients\"\naxislegend()\n\nerr_coef = restored_coef .- phase.coef\nerr_coef[1] = 0\nax, _ = scatter(fig[2, 1], err_coef)\nax.title = \"Coefficient restoration error\"\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The error is error is about the same.","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"We can compare the phases themselves","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"ph_u .-= restored_coef[1]\nerr = (ph_u .- phase)\nfig, ax, hm = showarray(bboxview(err .* conf2.mask));\nax.aspect = 1\nColorbar(fig[1, 2], hm)\nax.title = \"Phase rmse = $(PhaseUtils.maskedphasermse(ph_u, phase, conf2.ap)/(2π)) λ\"\nfig","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The quite big error in the coefficient restoration compared with the error magnitude in the phases is not the numerical error of decomposition by Zernikes. Here is, for instance, the result of the decomposition of the input phase:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"rest = PhaseBases.decompose(collect(phase), z10)\nscatter(phase.coef)\nscatter!(rest)\ncurrent_figure()","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The error is negligible:","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"scatter(rest .- phase.coef; axis=(title=\"RMS error = $( norm(rest .- phase.coef))\",))","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"tutorials/GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Inverse/#Inverse-problem","page":"Introduction","title":"Inverse problem","text":"","category":"section"},{"location":"Inverse/","page":"Introduction","title":"Introduction","text":"The goal of the inverse problem in Phase Retrieval is to reconstruct the phase of the field  in the pupil field from the intensity measurements in the focal plane.","category":"page"},{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package is devoted to the forward and inverse problems of Phase Retrieval (PR).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"EditURL = \"../../../tutorials/Hardware.jl\"","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"tutorials/Hardware/#Hardware-types","page":"Forward model","title":"Hardware types","text":"","category":"section"},{"location":"tutorials/Hardware/#Camera-chip","page":"Forward model","title":"Camera chip","text":"","category":"section"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"CameraChip represents a device that outputs sampled field intensity quantized and packed in 8- or 16-bit integer per color channel (currently, only monochrome cameras are implemented).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This code sets up a camera with 5.2μm pixel, 1280 × 1024 frame, bitdepth and channeldepth  of 8 bits:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"using PhaseRetrieval\nusing PhasePlots\nusing CairoMakie\nusing ImageCore\ncam = CameraChip(; pixelsize=5.2um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Cameras can be also created using camerasdict dictionary. Let's consider examples of 8-bit and 12-bit cameras:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam8bit = camerasdict[\"UI1240\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"and","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"cam12bit = camerasdict[\"UI3860\"]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"and compare the results of using these two cameras to measure this  field created by a circular aperture:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"ap, _ = PhaseRetrieval.aperture(-1:0.025:1, -1:0.025:1, 0.9)\n\nshowarray(ap)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The field itself is represented by a complex array, which has this amplitude and phase (we can see that due to the aperture symmetry, the field in the focal plane is real, actually, and the phase take only values 0 and π):","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"imf = PhaseRetrieval.toimageplane(ap)\nshowarray(abs.(imf))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"showphasetight(angle.(imf))[1]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"And now we can quantize this field by our 8-bit and 12-bit example cameras","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"collect(cam8bit(imf))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"collect(cam12bit(imf))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"note: Note\nWe have used collect here, as CameraChip returns a mapped view of the field.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We can see that for our 12-bit camera, the measurements are represented by the last 12 bits of a 16-bit number (N4f12).","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We can hardly see the difference in the camera outputs. Compare 8bit (left) with 12 bit (right):","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Gray.(mosaicview(cam8bit(imf), cam12bit(imf); nrow=1, npad=5, fillvalue=1))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The difference is visible in the logarithmic scale. compare 8bit:  and 12 bit","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Gray.(\n    mosaicview(\n        logrescale(float.(cam8bit(imf))),\n        logrescale(float.(cam12bit(imf)));\n        nrow=1,\n        npad=5,\n        fillvalue=1,\n    )\n)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The difference appears because of the thresholding done by the quantization. Without the quantizations, the fields are the same:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Gray.(\n    mosaicview(\n        logrescale(float.(cam8bit(imf; exposure=AutoExposure(1), quantize=false))),\n        logrescale(float.(cam12bit(imf; exposure=AutoExposure(1), quantize=false)));\n        nrow=1,\n        npad=5,\n        fillvalue=1,\n    )\n)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We can, however, boost exposure 16 (=2⁴) times of the 8bit camera to see more rings:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Gray.(PhaseRetrieval.logrescale(float.(cam8bit(imf; exposure=AutoExposure(16)))))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We lost, of course, the information in the center of the PSF due to the oversaturation of the camera pixels.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"note: Note\nHere we have used already sampled optical filed imf, so there is no difference in the sampling rate performed by the cameras. This effect will be demonstrated in the next example.","category":"page"},{"location":"tutorials/Hardware/#SimConfig","page":"Forward model","title":"SimConfig","text":"","category":"section"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"SimConfig contains the necessary information for simulations.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Let's set up a simulation environment matching the following hardware setup: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length, and the PSF is registered with UI-1240 camera. For both lens and camera, we can use structures with self-explanatory names ImagingLens and CameraChip, which we combine in one structure called ImagingSensor:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"using PhaseRetrieval\nlens = ImagingLens(300mm, 25mm)\ncam = CameraChip(; pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)\nims = ImagingSensor(; lens=lens, cam=cam)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Now we can save all these definitions in a simulation config SimConfig. We also specify the wavelength here:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"conf1 = SimConfig(\"full_aperture\", ims, 633nm)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This creates an aperture array of correct dimensions which is suitable for the generation of a PSF using Fourier methods. If we check near the central pixel, we'll see that for this configuration the PSF is almost one pixel wide","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"p = psf(conf1.ap)\nusing CairoMakie # hide\nCairoMakie.activate!(; type=\"png\") # hide\nheatmap(rotr90(p[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Indeed, the Airy pattern should be about 9 microns wide","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"print(\"Airy size is 1.22λ/NA = $(airysize(conf1)/ um) μm\")","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"We might thus want to consider a smaller numerical aperture:","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"lens2 = PhaseRetrieval.diaphragm(lens, 10mm)\nims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)\nconf2 = SimConfig(\"10mm aperture\", ims2, 633nm)\np2 = psf(conf2.ap)\nheatmap(rotr90(p2[503:523, 631:651]); axis=(aspect=DataAspect(),))","category":"page"},{"location":"tutorials/Hardware/#Faster-creation-of-an-ImagingSensor","page":"Forward model","title":"Faster creation of an ImagingSensor","text":"","category":"section"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Some often used cameras are saved in camerasdict and lensesdict dictionaries","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"keys(camerasdict)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"So the imaging sensor can be created as","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"ims = ImagingSensor(; cam=camerasdict[\"UI1240\"], lens=lensesdict[\"F300A25\"])","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"SimConfig contains the necessary information for simulations.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"fieldnames(typeof(conf2))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"For instance, it contains the aperture mask.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"using PhasePlots\nshowarray(conf2.ap)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in dualroi field and can be used to construct the Zernike basis.","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"conf2.dualroi","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This can be used to create the Zernike basis","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"using PhaseBases\nbasis = ZernikeBW(conf2.dualroi, apdiameter(conf2), 10);\nshowphase(basis.elements[15] .* conf2.mask)[1]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"Or the same picture without unnecessary information (by default all phases will be shown scaled to (-π. π])","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"showphasetight(basis.elements[15] .* conf2.mask)[1]","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This is a combination of some low-order Zernike polynomials","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"phase = ModalPhase([4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π, basis)\nfig = Figure();\nshowphasetight(phase .* conf2.mask, fig)\nfig","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"For this aberrated phase the PSF is larger","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"p2 = psf(conf2.ap, phase)\nshowarray(p2; colormap=:grays)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"More details are visible in the logarithmic scale","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"showarray(PhaseRetrieval.logrescale(p2))","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"The SimConfigtype is callable and, if applied to an array of proper dimensions, generates a psf","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"p2 = conf2(phase)\nshowarray(p2; colormap=:grays)","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"","category":"page"},{"location":"tutorials/Hardware/","page":"Forward model","title":"Forward model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhaseRetrieval\nDocTestSetup = quote\n    using PhaseRetrieval\nend","category":"page"},{"location":"#PhaseRetrieval.jl-Documentation","page":"Home","title":"PhaseRetrieval.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\nPages = [\n        \"index.md\",\n        \"about.md\",\n        \"tutorials/GettingStarted.md\",\n        \"tutorials/Hardware.md\",  \n        \"Inverse.md\", \n        \"tutorials/Gonsalves.md\",                \n        \"tutorials/AP.md\",\n    ]\nDepth = 3","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseRetrieval]\nPrivate = false","category":"page"},{"location":"#PhaseRetrieval.camerasdict","page":"Home","title":"PhaseRetrieval.camerasdict","text":"`camerasdict` is a dictionary with often used cameras.\n\nUse keys(camerasdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.lensesdict","page":"Home","title":"PhaseRetrieval.lensesdict","text":"`lensesdict` is a dictionary with often used cameras.\n\nUse keys(lensesdict) to get the list of implemented cameras.\n\n\n\n\n\n","category":"constant"},{"location":"#PhaseRetrieval.AbstractPRproblem","page":"Home","title":"PhaseRetrieval.AbstractPRproblem","text":"Big class of general phase-retrieval-related problems.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.AutoExposure","page":"Home","title":"PhaseRetrieval.AutoExposure","text":"AutoExposure(s =1) <: PSFExposure\n\nType used to set exposure of the camera to s*m, where m is the exposure that images the maximal intensity of the frame as 1. For instance, if the same scene is imaged with AutoExposure(0.5), the brightest pixel will have value 0.5. Values of s larger than 1 produce over-exposured images.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip","page":"Home","title":"PhaseRetrieval.CameraChip","text":"CameraChip(pixelsize, imagesize; <keyword args>)\n\nCreate a camera chip with a given square pixel size and image size.\n\nYou can also specify the bit depth of the camera and the channel bit depth. For instance, 12-bit camera (bitdepth =12) often transfer its measurement packed in 16-bit number (channelbitdepth = 16).\n\nIf called on a complex field, output the image seen by the chip.\n\nSee also camerasdict, storagetype, intensity.\n\nArguments\n\npixelsize::Float64: size of the pixel. Only square pixels are supported.\nimagesize::Tuple{Int, Int}: (width, height) of the image.\nbitdepth::Int = 8: bit detpth of the camera.\nchannelbitdepth::Int = 8: channel bit depth of the camera.\n\nArguments can be specified in any order.\n\nExample\n\ncam = CameraChip(;\n    pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8\n)\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.25:1,-1:.25:1,.8); ap\n9×9 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> imf = PhaseRetrieval.toimageplane(ap);\n\njulia> cam = camerasdict[\"UI3860\"];\n\njulia> cam(imf; exposure = AutoExposure(.7)) |> collect\n9×9 Array{N4f12,2} with eltype FixedPointNumbers.N4f12:\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0601  0.0  0.1411  0.4987  0.6999  0.4987  0.1411  0.0  0.0601\n 0.0427  0.0  0.1006  0.3553  0.4987  0.3553  0.1006  0.0  0.0427\n 0.0122  0.0  0.0286  0.1006  0.1411  0.1006  0.0286  0.0  0.0122\n 0.0     0.0  0.0     0.0     0.0     0.0     0.0     0.0  0.0\n 0.0051  0.0  0.0122  0.0427  0.0601  0.0427  0.0122  0.0  0.0051\n\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.CameraChip-Union{Tuple{Array{T}}, Tuple{T}} where T<:Real","page":"Home","title":"PhaseRetrieval.CameraChip","text":"(cam::CameraChip)(\nintensity; exposure::PSFExposure=AutoExposure(), quantize=true, noise=(0, 0)\n\n)\n\nCalculate image generated by the camera for the given filed inensity.     If used with complex array, first converts it to intesity\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.GS","page":"Home","title":"PhaseRetrieval.GS","text":"Gerchberg-Saxton, classical method to solve PR problem\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.GSparam","page":"Home","title":"PhaseRetrieval.GSparam","text":"GSparam(; ϕ⁰, maxit, maxϵ, keephistory, snapshots)\n\nParameters for a concrete realisation of GS method.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingLens","page":"Home","title":"PhaseRetrieval.ImagingLens","text":"ImagingLens(;focallength, aperture)\n\nCreate fixed focal length lens with focus = focallength and aperture dimater aperture.\n\nArguments can be speciefied in any order.\n\nSee also diaphragm, lensesdict.\n\nExample\n\njulia> lens = ImagingLens(300mm, 25mm)\nImaging Lens with\n  f:\t300.0 mm and\n  D:\t25.0 mm\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ImagingSensor","page":"Home","title":"PhaseRetrieval.ImagingSensor","text":"ImagingSensor(lens=lens, cam=cam)\n\nImaging sensor or camera consisting of a lens lens and camera chip cam.\n\nCreate a sensor using keyword syntaxis (in any order), lens and cam are required\n\nims = ImagingSensor(lens = ::ImagingLens, cam = ::CameraChip)\n\nSee also roi, diaphragm.\n\nArguments:\n\nlens::ImagingLens: lens of the camera\ncam::CameraChip: sensor chip of the camera\n\nIf lens and cam are strings, corresponding values from lensesdict and camerasdict are used.\n\nOther possible keywords to simulate misalingnment (not implemented yet)\n\nfocal_distance = lens.focallength: Distance between the lens and the sensor.\nlensorigin = [0.,0.]: nodal point, expressed in length units (mm or um)\nChip plane misalingment angles:\nα = 0: rotation in x\nβ = 0: rotation in y\nγ = 0: rotation in z\n\nExample\n\njulia> ImagingSensor(lens = ImagingLens(300mm, 25mm),\n           cam = CameraChip(\n               pixelsize=5.2um,\n               imagesize=(1280, 1024),\n               bitdepth=8,\n               channelbitdepth=8\n               )\n           )\nImaging Sensor made with:\n  Imaging Lens with\n  f:\t300.0 mm and\n  D:\t25.0 mm and\n  Camera with\n\tpixel size 5.2 × 5.2 μm²,\n\t(1280, 1024) frame and\n\t8/8 bit/channel output.\n\njulia> diaphragm(ImagingSensor(lens = lensesdict[\"F300A25\"], cam= camerasdict[\"UI1540\"]), 10mm)\nImaging Sensor made with:\n  Imaging Lens with\n  f:\t300.0 mm and\n  D:\t10.0 mm and\n  Camera with\n\tpixel size 5.2 × 5.2 μm²,\n\t(1280, 1024) frame and\n\t8/8 bit/channel output.\n\njulia> ImagingSensor(\"F300A25\",  \"UI1540\")\nImaging Sensor made with:\n  Imaging Lens with\n  f:\t300.0 mm and\n  D:\t25.0 mm and\n  Camera with\n\tpixel size 5.2 × 5.2 μm²,\n\t(1280, 1024) frame and\n\t8/8 bit/channel output.\n\nSee also focallength, focaldistance, apdiameter.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.LinearPolarization","page":"Home","title":"PhaseRetrieval.LinearPolarization","text":"LinearPolarization\n\nDOCSTRING\n\nFields:\n\norientation_angle::Float64: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PDPRproblem","page":"Home","title":"PhaseRetrieval.PDPRproblem","text":"PDPRproblem(a, [Aᵢ], [ϕᵢ])\n\nPhase-diverse phase-retrieval problem of finding complex arrays x, Xᵢ such that   |x| = a, |Xᵢ| = Aᵢ, and Xᵢ =F(x exp(im ϕᵢ)), where F denotes the Fourier transform and ϕᵢ are predefined phase diversities. Note that the problem is not required to be consistent.\n\nPDPRproblem(a, [Aᵢ], [ϕᵢ] ; center = true, renormalize = true) -> PDPRproblem\n\nDefault constructor for PDPRproblem from the arrays which origin is supposed to be at their center and  array Aᵢ are renormalised to satisfy the Parseval equation.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblem","page":"Home","title":"PhaseRetrieval.PRproblem","text":"PRproblem(a, A)\n\nClassical phase-retrieval problem of finding complex arrays x, X such that   |x| = a, |X| = A, and X =F(x), where F denotes the Fourier transform. Note that the problem is not required to be consistent.\n\nPRproblem(a,A; center = true, renormalize = true) -> PRproblem\n\nDefault constructor for PRproblem from the arrays which origin is supposed to be at their center and the second array is renormalised to satisfy the Parseval equation.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.PRproblemSat","page":"Home","title":"PhaseRetrieval.PRproblemSat","text":"PRproblemSat(a, A, satlevel)\n\nSaturated PSF phase-retrieval problem of finding complex arrays x, X such that   |x| = a, max(|X|, satlevel) = A, and X =F(x), where F denotes the Fourier transform.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ScalarComplexAmplitude","page":"Home","title":"PhaseRetrieval.ScalarComplexAmplitude","text":"ScalarComplexAmplitude <: AbstractScalarComplexAmplitude\n\nStructure containing separately in its fields amplitude and phase.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.ScalarPolarization","page":"Home","title":"PhaseRetrieval.ScalarPolarization","text":"ScalarPolarization\n\n\"Fake\" polarization used to represent a scalar wave.\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.SimConfig","page":"Home","title":"PhaseRetrieval.SimConfig","text":"SimConfig(name::String, ims::PhaseRetrieval.ImagingSensor, λ::Float64; method = PSFMethods.Fourier()) creates forward-model\nsimulation environment, using algorithm defined by `method`,\nfor the PR problem obtained with  `ims` image sensor (camera + lens) at\nwavelength `λ`. `name` is a sting identifacator used for, for instace, plotting labels.\n\nSimConfig{PSFMethods.Fourier} contains the following fields:\n\n- name::String\n- ims::PhaseRetrieval.ImagingSensor -- imaging sensor used in the configuration\n- λ::Float64 -- light wavelength\n- roi::CartesianDomain2D -- coordiantes in the image plane\n- dualroi::CartesianDomain2D -- coordinates in the pupil plane\n- ap::Array{Float64,2} -- amplitude of the pupil function\n- mask::Array{Float64,2} -- array of NaNs and 1s defining the aperture support\n- phases::Dict{String, PhaseBases.Phase} -- phase aberrrations present in the config\n- diversity::Dict{String, PhaseBases.Phase} -- phase diversities used for PSF generation\n- modulation::Dict{String, Array{Float64,2}} -- amplitude modulations used for calculation of the vectorial PSF\n\n\n\n\n\n","category":"type"},{"location":"#PhaseRetrieval.hwConfig-Tuple{String, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.hwConfig","text":"hwConfig(s::String, f, λ, d) creates a hardware configuration with\n`s` camera, lens with a focal length `f` and aperture `d` and using wavelenght\n`λ`.\n\nExample\n\nconf1 = hwConfig(\"UI1540\", 300mm, 633nm,25mm) creates a configuration\nbased on UI-1540 camera, with a 1 inch lens with focal length 300mm and He-Ne laser.\n\n\n\n\n\n","category":"method"},{"location":"#AlternatingProjections.AbstractProblems.solve-Tuple{AbstractPRproblem, GS, Vararg{Any}}","page":"Home","title":"AlternatingProjections.AbstractProblems.solve","text":"solve(pr::PRproblem, alg::GS, args...)\n\nSolve PR problem using GS method. Any change of the GS parameters can be given\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.SHdiversity","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(size, cellsize, celloffset=0, α=0)\n\nGenerate SH diversity phase of given overall size, cellsize, central cell offset and rotation angle α.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.SHdiversity-Tuple{AbstractRange, AbstractRange, Any, Any, Any}","page":"Home","title":"PhaseRetrieval.SHdiversity","text":"SHdiversity(xrange, yrange, e₁, e₂, o)\n\nGenerate SH diversity phase on array xrange × yrange with cell based on orthogonal grid formed by vectors  e₁, e₂, and origin at o.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.appsftoPR-Tuple{Any, Any}","page":"Home","title":"PhaseRetrieval.appsftoPR","text":"appsftoPR(ap,psfimage) constructs a phase retrieval problem from two real arrays, representing the pupil and the focal planes intensity distributions.\n\nThe aperture and PSF are assumed to be centred in the array.\n\nExamples\n\n\nap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8);\npsfimage = psf(ap);\n\npr = appsftoPR(ap,psfimage)\n\n# output\nPRproblem{Float64, 2}([1.0 0.0 … 1.0 1.0; 0.0 0.0 … 0.0 1.0; … ; 1.0 0.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 4.432323038895129 0.7324956483358351 … 4.432323038895129 6.182768610120747; … ; 8.857504209336042 4.432323038895129 … 8.857504209336042 10.878351222990858; 10.878351222990858 6.182768610120746 … 10.878351222990858 12.999999999999996])\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.diaphragm-Tuple{ImagingLens, Float64}","page":"Home","title":"PhaseRetrieval.diaphragm","text":"diaphragm(lens, diam)\n\nChange the lens diameter of an ImagingLens or an ImagingSensor.\n\nDiaphragm can be larger than the lens diameter (there is no \"hardware limitation\").\n\nExample\n\njulia> diaphragm(ImagingLens(300mm, 25mm), 10mm)\nImaging Lens with\n  f:\t300.0 mm and\n  D:\t10.0 mm\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.focaldistance-Tuple{ImagingSensor}","page":"Home","title":"PhaseRetrieval.focaldistance","text":"focaldistance(ims [,z])\n\nGet/set the distance from the lens to the imaging plane.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.incoherent_psf-Tuple{Array}","page":"Home","title":"PhaseRetrieval.incoherent_psf","text":"incoherent_psf(array<:Array)\n\nCalculate 2D array corresponding to the incoherent sum of the PSF formed by slices array[:,:,ind...] for all possible indici ind.\n\njulia> incoherent_psf(ones(3,3,2,3))\n3×3 Matrix{Float64}:\n 0.0    0.0  0.0\n 0.0  486.0  0.0\n 0.0    0.0  0.0\n\njulia> incoherent_psf(ones(4,4,2,2,1))\n4×4 Matrix{Float64}:\n 0.0  0.0     0.0  0.0\n 0.0  0.0     0.0  0.0\n 0.0  0.0  1024.0  0.0\n 0.0  0.0     0.0  0.0\n\njulia> incoherent_psf(ones(4,4))\n4×4 Matrix{Float64}:\n 0.0  0.0    0.0  0.0\n 0.0  0.0    0.0  0.0\n 0.0  0.0  256.0  0.0\n 0.0  0.0    0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.logrescale","page":"Home","title":"PhaseRetrieval.logrescale","text":"logrescale(array, α = 5)\n\nRescale in log-scale: maximum will correspond to 1, 10^-α will correspond to 0.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseRetrieval.psf-Tuple{AbstractArray}","page":"Home","title":"PhaseRetrieval.psf","text":"psf(amplitude, phase) -> psfimage\npsf(pupilfield) -> psfimage\n\nCalculate psf for given amplitude and phase. Both PSF and pupil arrays are assumed     to have the origin in their center pixel ((N+1)÷2 for dimension size N).\n\nExamples\n\njulia> ap,_ = PhaseRetrieval.aperture(-1:.2:1,-1:.2:1,.8); ap\n11×11 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> Int.(round.(psf(ap)))\n11×11 Matrix{Int64}:\n 18  3   1   2    0    1    0   2   1  3  18\n  3  0   6   5    0    1    0   5   6  0   3\n  1  6  11   4    1    5    1   4  11  6   1\n  2  5   4   1   20   38   20   1   4  5   2\n  0  0   1  20   78  118   78  20   1  0   0\n  1  1   5  38  118  169  118  38   5  1   1\n  0  0   1  20   78  118   78  20   1  0   0\n  2  5   4   1   20   38   20   1   4  5   2\n  1  6  11   4    1    5    1   4  11  6   1\n  3  0   6   5    0    1    0   5   6  0   3\n 18  3   1   2    0    1    0   2   1  3  18\n\n\njulia> psf(ones(3,3),zeros(3,3))\n3×3 Matrix{Float64}:\n 0.0   0.0  0.0\n 0.0  81.0  0.0\n 0.0   0.0  0.0\n\njulia> psf(ones(Complex{Float64},4,4))\n4×4 Matrix{Float64}:\n 0.0  0.0    0.0  0.0\n 0.0  0.0    0.0  0.0\n 0.0  0.0  256.0  0.0\n 0.0  0.0    0.0  0.0\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.roi-Tuple{CameraChip, Tuple{Int64, Int64}}","page":"Home","title":"PhaseRetrieval.roi","text":"roi(cam, dims)\n\nCreate camera that represents centered regeion of interest (ROI) of cam.\n\nROI can be larger than the camera size! :-)\n\nArguments\n\ncam: camera (CameraChip) or imaging sensor (ImagingSensor)\ndims::Tuple{Int, Int}: new (width, height) of the image.  Single number defines a square ROI.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.stochasticSolve-Tuple","page":"Home","title":"PhaseRetrieval.stochasticSolve","text":"stochasticSolve(\npr::AbstractPRproblem,\nalgs::Tuple{Vararg{IterativeAlgorithm}},\nargs...;\nnruns=10,\nϕscale=2π,\nquality=x ->\n    LinearAlgebra.norm(solution(x) .- lasty(x)) / LinearAlgebra.norm(solution(x)),\nkwargs...,\n\n)\n\nSolve problem pr with perturbing the initial value with a random phase term uniformly distributed in interval [0,ϕscale]. Run nrun times and return solution with the minimal value of quality function.\n\nSee also  stochasticSolveKeep.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.stochasticSolveKeep-Tuple{AbstractPRproblem, Tuple{Vararg{AlternatingProjections.AbstractProblems.IterativeAlgorithm}}, Vararg{Any}}","page":"Home","title":"PhaseRetrieval.stochasticSolveKeep","text":"stochasticSolveKeep(\npr::AbstractPRproblem,\nalgs::Tuple{Vararg{IterativeAlgorithm}},\nargs...;\nnruns=10,\nϕscale=2π,\nquality=x ->\n    LinearAlgebra.norm(solution(x) .- lasty(x)) / LinearAlgebra.norm(solution(x)),\nkwargs...,\n\n)\n\nSolve problem pr with perturbing the initial value with a random phase term uniformly distributed in interval [0,ϕscale]. Run nrun times and return vector of tuples of the solution and values of quality function.\n\nSee also stochasticSolve.\n\n\n\n\n\n","category":"method"},{"location":"#PhaseRetrieval.throughfocus-Tuple{SimConfig}","page":"Home","title":"PhaseRetrieval.throughfocus","text":"throughfocus(conf::SimConfig, Δz)\n\nCalculate the phase aberration (defocus) corresponding to the axial disaplcament on length Δz.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"EditURL = \"../../../tutorials/AP.jl\"","category":"page"},{"location":"tutorials/AP/#Alternative-projections-based-methods","page":"AP-based methods","title":"Alternative-projections-based methods","text":"","category":"section"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"","category":"page"},{"location":"tutorials/AP/","page":"AP-based methods","title":"AP-based methods","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"EditURL = \"../../../tutorials/Gonsalves.jl\"","category":"page"},{"location":"tutorials/Gonsalves/#Method-of-Gonsalves-for-small-phases","page":"Gonsalves's method","title":"Method of Gonsalves for small phases","text":"","category":"section"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"","category":"page"},{"location":"tutorials/Gonsalves/","page":"Gonsalves's method","title":"Gonsalves's method","text":"This page was generated using Literate.jl.","category":"page"}]
}
