<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forward model · PhaseRetrieval.jl</title><meta name="title" content="Forward model · PhaseRetrieval.jl"/><meta property="og:title" content="Forward model · PhaseRetrieval.jl"/><meta property="twitter:title" content="Forward model · PhaseRetrieval.jl"/><meta name="description" content="Documentation for PhaseRetrieval.jl."/><meta property="og:description" content="Documentation for PhaseRetrieval.jl."/><meta property="twitter:description" content="Documentation for PhaseRetrieval.jl."/><meta property="og:url" content="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/Hardware/"/><meta property="twitter:url" content="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/Hardware/"/><link rel="canonical" href="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/Hardware/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhaseRetrieval.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../GettingStarted/">Getting Started</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Forward model</a><ul class="internal"><li><a class="tocitem" href="#Camera-chip"><span>Camera chip</span></a></li><li><a class="tocitem" href="#SimConfig"><span>SimConfig</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Inverse Problem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Inverse/">Introduction</a></li><li><a class="tocitem" href="../Gonsalves/">Gonsalves&#39;s method</a></li><li><a class="tocitem" href="../AP/">AP-based methods</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Forward model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Forward model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/Hardware.jl#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hardware-types"><a class="docs-heading-anchor" href="#Hardware-types">Hardware types</a><a id="Hardware-types-1"></a><a class="docs-heading-anchor-permalink" href="#Hardware-types" title="Permalink"></a></h1><h2 id="Camera-chip"><a class="docs-heading-anchor" href="#Camera-chip">Camera chip</a><a id="Camera-chip-1"></a><a class="docs-heading-anchor-permalink" href="#Camera-chip" title="Permalink"></a></h2><p><a href="../../#PhaseRetrieval.CameraChip"><code>CameraChip</code></a> represents a device that outputs sampled field intensity quantized and packed in 8- or 16-bit integer per color channel (currently, only monochrome cameras are implemented).</p><p>This code sets up a camera with 5.2μm pixel, 1280 × 1024 frame, <code>bitdepth</code> and <code>channeldepth</code>  of 8 bits:</p><pre><code class="language-julia hljs">using PhaseRetrieval
using PhasePlots
using CairoMakie
using ImageCore
cam = CameraChip(; pixelsize=5.2um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Camera with 
	square pixel 5.2 μm, 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><p>Cameras can be also created using <a href="../../#PhaseRetrieval.camerasdict"><code>camerasdict</code></a> dictionary. Let&#39;s consider examples of 8-bit and 12-bit cameras:</p><pre><code class="language-julia hljs">cam8bit = camerasdict[&quot;UI1240&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Camera with 
	square pixel 5.3 μm, 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><p>and</p><pre><code class="language-julia hljs">cam12bit = camerasdict[&quot;UI3860&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Camera with 
	square pixel 2.9 μm, 
	(1936, 1096) frame and 
	12/16 bit/channel output.</code></pre><p>and compare the results of using these two cameras to measure this  field created by a circular aperture:</p><pre><code class="language-julia hljs">ap, _ = PhaseRetrieval.aperture(-1:0.025:1, -1:0.025:1, 0.9)

showarray(ap)</code></pre><img src="b25cdf12.png" alt="Example block output"/><p>The field itself is represented by a complex array, which has this amplitude and phase (we can see that due to the aperture symmetry, the field in the focal plane is real, actually, and the phase take only values 0 and π):</p><pre><code class="language-julia hljs">imf = PhaseRetrieval.toimageplane(ap)
showarray(abs.(imf))</code></pre><img src="22b26f18.png" alt="Example block output"/><pre><code class="language-julia hljs">showphasetight(angle.(imf))[1]</code></pre><img src="a10bdefb.png" alt="Example block output"/><p>And now we can quantize this field by our 8-bit and 12-bit example cameras</p><pre><code class="language-julia hljs">collect(cam8bit(imf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">81×81 Array{N0f8,2} with eltype FixedPointNumbers.N0f8:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 ⋮                        ⋮              ⋱       ⋮                        ⋮
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><pre><code class="language-julia hljs">collect(cam12bit(imf))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">81×81 Array{N4f12,2} with eltype FixedPointNumbers.N4f12:
 0.0     0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0002  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0002
 ⋮                           ⋮         ⋱  ⋮                        ⋮
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0
 0.0     0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We have used <code>collect</code> here, as <code>CameraChip</code> returns a mapped view of the field.</p></div></div><p>We can see that for our 12-bit camera, the measurements are represented by the last 12 bits of a 16-bit number (<a href="https://github.com/JuliaMath/FixedPointNumbers.jl"><code>N4f12</code></a>).</p><p>We can hardly see the difference in the camera outputs. Compare 8bit (left) with 12 bit (right):</p><pre><code class="language-julia hljs">Gray.(mosaicview(cam8bit(imf), cam12bit(imf); nrow=1, npad=5, fillvalue=1))</code></pre><img src="f5210dfd.svg" alt="Example block output"/><p>The difference is visible in the logarithmic scale. compare 8bit:  and 12 bit</p><pre><code class="language-julia hljs">Gray.(
    mosaicview(
        logrescale(float.(cam8bit(imf))),
        logrescale(float.(cam12bit(imf)));
        nrow=1,
        npad=5,
        fillvalue=1,
    )
)</code></pre><img src="b1069a5c.svg" alt="Example block output"/><p>The difference appears because of the thresholding done by the quantization. Without the quantizations, the fields are the same:</p><pre><code class="language-julia hljs">Gray.(
    mosaicview(
        logrescale(float.(cam8bit(imf, AutoExposure(1), false))),
        logrescale(float.(cam12bit(imf, AutoExposure(1), false)));
        nrow=1,
        npad=5,
        fillvalue=1,
    )
)</code></pre><img src="c48b34ff.svg" alt="Example block output"/><p>We can, however, boost exposure 16 (=2⁴) times of the 8bit camera to see more rings:</p><pre><code class="language-julia hljs">Gray.(PhaseRetrieval.logrescale(float.(cam8bit(imf, AutoExposure(16)))))</code></pre><img src="a58caa1e.svg" alt="Example block output"/><p>We lost, of course, the information in the center of the PSF due to the oversaturation of the camera pixels.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here we have used already sampled optical filed <code>imf</code>, so there is no difference in the sampling rate performed by the cameras. This effect will be demonstrated in the next example.</p></div></div><h2 id="SimConfig"><a class="docs-heading-anchor" href="#SimConfig">SimConfig</a><a id="SimConfig-1"></a><a class="docs-heading-anchor-permalink" href="#SimConfig" title="Permalink"></a></h2><p><code>SimConfig</code> contains the necessary information for simulations.</p><p>Let&#39;s set up a simulation environment matching the following hardware setup: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length, and the PSF is registered with <a href="https://en.ids-imaging.com/store/products/cameras/ui-1240le.html">UI-1240 camera</a>. For both lens and camera, we can use structures with self-explanatory names <a href="../../#PhaseRetrieval.ImagingLens"><code>ImagingLens</code></a> and <a href="../../#PhaseRetrieval.CameraChip"><code>CameraChip</code></a>, which we combine in one structure called <a href="../../#PhaseRetrieval.ImagingSensor"><code>ImagingSensor</code></a>:</p><pre><code class="language-julia hljs">using PhaseRetrieval
lens = ImagingLens(300mm, 25mm)
cam = CameraChip(; pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)
ims = ImagingSensor(; lens=lens, cam=cam)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	square pixel 5.3 μm, 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><p>Now we can save all these definitions in a simulation config <a href="../../#PhaseRetrieval.SimConfig"><code>SimConfig</code></a>. We also specify the wavelength here:</p><pre><code class="language-julia hljs">conf1 = SimConfig(&quot;full_aperture&quot;, ims, 633nm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation configuration with the properties:

name:		 full_aperture
wavelength:	 6.33e-7
Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	square pixel 5.3 μm, 
	(1280, 1024) frame and 
	8/8 bit/channel output.
with wavefront aberrrations: String[]
with phase diversities String[]
</code></pre><p>This creates an aperture array of correct dimensions which is suitable for the generation of a PSF using Fourier methods. If we check near the central pixel, we&#39;ll see that for this configuration the PSF is almost one pixel wide</p><pre><code class="language-julia hljs">p = psf(conf1.ap)
heatmap(rotr90(p[503:523, 631:651]); axis=(aspect=DataAspect(),))</code></pre><img src="a84dcb50.png" alt="Example block output"/><p>Indeed, the Airy pattern should be about 9 microns wide</p><pre><code class="language-julia hljs">print(&quot;Airy size is 1.22λ/NA = $(airysize(conf1)/ um) μm&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Airy size is 1.22λ/NA = 9.267119999999998 μm</code></pre><p>We might thus want to consider a smaller numerical aperture:</p><pre><code class="language-julia hljs">lens2 = PhaseRetrieval.diaphragm(lens, 10mm)
ims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)
conf2 = SimConfig(&quot;10mm aperture&quot;, ims2, 633nm)
p2 = psf(conf2.ap)
heatmap(rotr90(p2[503:523, 631:651]); axis=(aspect=DataAspect(),))</code></pre><img src="545990f7.png" alt="Example block output"/><h4 id="Faster-creation-of-an-ImagingSensor"><a class="docs-heading-anchor" href="#Faster-creation-of-an-ImagingSensor">Faster creation of an <code>ImagingSensor</code></a><a id="Faster-creation-of-an-ImagingSensor-1"></a><a class="docs-heading-anchor-permalink" href="#Faster-creation-of-an-ImagingSensor" title="Permalink"></a></h4><p>Some often used cameras are saved in <a href="../../#PhaseRetrieval.camerasdict"><code>camerasdict</code></a> and <a href="../../#PhaseRetrieval.lensesdict"><code>lensesdict</code></a> dictionaries</p><pre><code class="language-julia hljs">keys(camerasdict)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KeySet for a Dict{Any, Any} with 7 entries. Keys:
  &quot;UI1540&quot;
  &quot;UI3860&quot;
  &quot;UI1490&quot;
  &quot;UI3260&quot;
  &quot;MC203MG&quot;
  &quot;UI1240&quot;
  &quot;UI2210&quot;</code></pre><p>So the imaging sensor can be created as</p><pre><code class="language-julia hljs">ims = ImagingSensor(; cam=camerasdict[&quot;UI1240&quot;], lens=lensesdict[&quot;F300A25&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	square pixel 5.3 μm, 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><p><code>SimConfig</code> contains the necessary information for simulations.</p><pre><code class="language-julia hljs">fieldnames(typeof(conf2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(:name, :ims, :λ, :roi, :dualroi, :ap, :mask, :phases, :diversity)</code></pre><p>For instance, it contains the aperture mask.</p><pre><code class="language-julia hljs">using PhasePlots
showarray(conf2.ap)</code></pre><img src="152a1c79.png" alt="Example block output"/><p>The dimensions of the mask correspond to the dimensions of the sampled image plane, but the overall size corresponds to the inverse of the pixel size. This information is contained in <code>dualroi</code> field and can be used to construct the Zernike basis.</p><pre><code class="language-julia hljs">conf2.dualroi</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SampledDomains.CartesianDomain2D(-0.017915094339622642:2.7992334905660383e-5:0.017887102004716986, -0.017915094339622642:3.499041863207547e-5:0.017880103920990566)</code></pre><p>This can be used to create the Zernike basis</p><pre><code class="language-julia hljs">using PhaseBases
basis = ZernikeBW(conf2.dualroi, apdiameter(conf2), 10);
showphase(basis.elements[15] .* conf2.mask)[1]</code></pre><img src="0c08e682.png" alt="Example block output"/><p>Or the same picture without unnecessary information (by default all phases will be shown scaled to (-π. π])</p><pre><code class="language-julia hljs">showphasetight(basis.elements[15] .* conf2.mask)[1]</code></pre><img src="d19cd1be.png" alt="Example block output"/><p>This is a combination of some low-order Zernike polynomials</p><pre><code class="language-julia hljs">phase = ModalPhase([4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π, basis)
fig = Figure();
showphasetight(phase .* conf2.mask, fig)
fig</code></pre><img src="298f5f13.png" alt="Example block output"/><p>For this aberrated phase the PSF is larger</p><pre><code class="language-julia hljs">p2 = psf(conf2.ap, phase)
showarray(p2, :grays)</code></pre><img src="1ff5d06e.png" alt="Example block output"/><p>More details are visible in the logarithmic scale</p><pre><code class="language-julia hljs">showarray(PhaseRetrieval.logrescale(p2))</code></pre><img src="4dcfdfec.png" alt="Example block output"/><p>The <code>SimConfig</code>type is callable and, if applied to an array of proper dimensions, generates a psf</p><pre><code class="language-julia hljs">p2 = conf2(phase)
showarray(p2, :grays)</code></pre><img src="1ff5d06e-001.png" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GettingStarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../../Inverse/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 8 December 2023 16:22">Friday 8 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
