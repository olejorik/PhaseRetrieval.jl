<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · PhaseRetrieval.jl</title><meta name="title" content="Getting Started · PhaseRetrieval.jl"/><meta property="og:title" content="Getting Started · PhaseRetrieval.jl"/><meta property="twitter:title" content="Getting Started · PhaseRetrieval.jl"/><meta name="description" content="Documentation for PhaseRetrieval.jl."/><meta property="og:description" content="Documentation for PhaseRetrieval.jl."/><meta property="twitter:description" content="Documentation for PhaseRetrieval.jl."/><meta property="og:url" content="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/GettingStarted/"/><meta property="twitter:url" content="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/GettingStarted/"/><link rel="canonical" href="https://olejorik.github.io/PhaseRetrieval.jl/stable/tutorials/GettingStarted/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhaseRetrieval.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#tutorial-forward"><span>Forward model</span></a></li><li><a class="tocitem" href="#tutorial-inverse"><span>Inverse problem</span></a></li><li><a class="tocitem" href="#Using-phase-diversity"><span>Using phase diversity</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../Hardware/">Forward model</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Inverse Problem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Inverse/">Introduction</a></li><li><a class="tocitem" href="../Gonsalves/">Gonsalves&#39;s method</a></li><li><a class="tocitem" href="../AP/">AP-based methods</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/olejorik/PhaseRetrieval.jl/blob/main/tutorials/GettingStarted.jl#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><p>The goal of this package is to provide tools for the forward and inverse problems of the Phase Retrieval (PR). The examples below show how to set up a simulation environment and how to form a PR problem from given measured PSF and an aperture.</p><ul><li><a href="#Getting-started">Getting started</a></li><li class="no-marker"><ul><li><a href="#tutorial-forward">Forward model</a></li><li><a href="#tutorial-inverse">Inverse problem</a></li><li><a href="#Using-phase-diversity">Using phase diversity</a></li></ul></li></ul><h2 id="tutorial-forward"><a class="docs-heading-anchor" href="#tutorial-forward">Forward model</a><a id="tutorial-forward-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-forward" title="Permalink"></a></h2><p>For the PR problem, the forward model is a simulation of a realistic readout of a camera of a PSF (or an extended object) under some predefined conditions.</p><h3 id="Initialising-the-simulation"><a class="docs-heading-anchor" href="#Initialising-the-simulation">Initialising the simulation</a><a id="Initialising-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialising-the-simulation" title="Permalink"></a></h3><p>Let&#39;s set up a simulation environment matching the following hardware setup: a beam with a footprint of 1 inch (25 mm) diameter is focused with a lens of 300 mm focal length, and the PSF is registered with <a href="https://en.ids-imaging.com/store/products/cameras/ui-1240le.html">UI-1240 camera</a>. For both lens and camera, we can use structures with self-explanatory names <a href="../../#PhaseRetrieval.ImagingLens"><code>ImagingLens</code></a> and <a href="../../#PhaseRetrieval.CameraChip"><code>CameraChip</code></a>, which we combine in one structure called <a href="../../#PhaseRetrieval.ImagingSensor"><code>ImagingSensor</code></a>:</p><pre><code class="language-julia hljs">using PhaseRetrieval
lens = ImagingLens(300mm, 25mm)
cam = CameraChip(; pixelsize=5.3um, imagesize=(1280, 1024), bitdepth=8, channelbitdepth=8)
ims = ImagingSensor(; lens=lens, cam=cam)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	pixel size 5.3 × 5.3 μm², 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><p>Now we can save all these definitions in a simulation config <a href="../Hardware/#SimConfig"><code>SimConfig</code></a>. We also specify the wavelength here:</p><pre><code class="language-julia hljs">conf1 = SimConfig(&quot;full_aperture&quot;, ims, 633nm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation configuration with the properties:

name:		 full_aperture
wavelength:	 6.33e-7
Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	pixel size 5.3 × 5.3 μm², 
	(1280, 1024) frame and 
	8/8 bit/channel output.
with wavefront aberrrations: String[]
with phase diversities ()
</code></pre><p>This creates a simulation configuration for the generation of a PSF using <a href="@ref"><code>PSFMethods.Fourier</code></a> methods. If we check near the central pixel, we&#39;ll see that for this configuration the PSF is almost one pixel wide. To crop central part of the image, we&#39;ll use <code>crop</code> function from <code>PhaseUtils</code> package.</p><pre><code class="language-julia hljs">p = psf(conf1)
using PhaseUtils
heatmap(rotr90(crop(p, 9)); axis=(aspect=DataAspect(),)) # show central 9 pixels</code></pre><img src="9c6a9a8d.png" alt="Example block output"/><p>Indeed, the Airy pattern should be about 9 microns wide</p><pre><code class="language-julia hljs">print(&quot;Airy size is 1.22λ/NA = $(airysize(conf1)/ um) μm&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Airy size is 1.22λ/NA = 9.267119999999998 μm</code></pre><p>We might thus want to consider a smaller numerical aperture:</p><pre><code class="language-julia hljs">lens2 = PhaseRetrieval.diaphragm(lens, 10mm)
ims2 = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=cam)
conf2 = SimConfig(&quot;10mm aperture&quot;, ims2, 633nm)
p2 = psf(conf2)
heatmap(rotr90(crop(p2, 9)); axis=(aspect=DataAspect(),))</code></pre><img src="89764da1.png" alt="Example block output"/><h3 id="Faster-creation-of-an-ImagingSensor"><a class="docs-heading-anchor" href="#Faster-creation-of-an-ImagingSensor">Faster creation of an <code>ImagingSensor</code></a><a id="Faster-creation-of-an-ImagingSensor-1"></a><a class="docs-heading-anchor-permalink" href="#Faster-creation-of-an-ImagingSensor" title="Permalink"></a></h3><p>Some often used cameras are saved in <a href="../../#PhaseRetrieval.camerasdict"><code>camerasdict</code></a> and <a href="../../#PhaseRetrieval.lensesdict"><code>lensesdict</code></a> dictionaries</p><pre><code class="language-julia hljs">keys(camerasdict)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">KeySet for a Dict{Any, Any} with 7 entries. Keys:
  &quot;UI1540&quot;
  &quot;UI3860&quot;
  &quot;UI1490&quot;
  &quot;UI3260&quot;
  &quot;MC203MG&quot;
  &quot;UI1240&quot;
  &quot;UI2210&quot;</code></pre><p>So the imaging sensor can be created as</p><pre><code class="language-julia hljs">ims = ImagingSensor(; cam=camerasdict[&quot;UI1240&quot;], lens=lensesdict[&quot;F300A25&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	25.0 mm and 
  Camera with 
	pixel size 5.3 × 5.3 μm², 
	(1280, 1024) frame and 
	8/8 bit/channel output.</code></pre><h3 id="Quantisation-and-exposure-level"><a class="docs-heading-anchor" href="#Quantisation-and-exposure-level">Quantisation and exposure level</a><a id="Quantisation-and-exposure-level-1"></a><a class="docs-heading-anchor-permalink" href="#Quantisation-and-exposure-level" title="Permalink"></a></h3><p>By default, the returned PSF approximates the output of a camera with finite bit resolution (8 bits in our case):</p><pre><code class="language-julia hljs">eltype(p2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">N0f8<span class="sgr90"> (alias for FixedPointNumbers.Normed{UInt8, 8})</span></code></pre><p>One can use <code>Images.jl</code> package to obtain images as saved by the camera: The whole frame:</p><pre><code class="language-julia hljs">using ImageCore
save(&quot;psf2.png&quot;, Gray.(p2))</code></pre><p><img src="../psf2.png" alt/></p><p>Crop of the central part</p><pre><code class="language-julia hljs">Gray.(crop(p2, 21))</code></pre><img src="d9abd504.svg" alt="Example block output"/><p>By default, the returned PSF is called between 0 and 1 (<a href="../../#PhaseRetrieval.AutoExposure"><code>AutoExposure</code></a> feature). This can be changed by passing additional parameters to <a href="../../#PhaseRetrieval.psf-Tuple{AbstractArray}"><code>psf</code></a> function. Here is an example of a PSF with 4 times longer exposure:</p><pre><code class="language-julia hljs">psf2_sat4 = psf(conf2; exposure=AutoExposure(4))
Gray.(crop(psf2_sat4, 21))</code></pre><img src="897717b0.svg" alt="Example block output"/><p>The same psf in logarithmic scale:</p><pre><code class="language-julia hljs">Gray.(logrescale(float.(crop(psf2_sat4, 21))))</code></pre><img src="ffdadb13.svg" alt="Example block output"/><p>And without quantisation:</p><pre><code class="language-julia hljs">psf2_sat4_float = psf(conf2; exposure=AutoExposure(4), quantize=false)
Gray.(logrescale(crop(psf2_sat4_float, 21)))</code></pre><img src="47d9e178.svg" alt="Example block output"/><h3 id="Adding-the-phase-aberration"><a class="docs-heading-anchor" href="#Adding-the-phase-aberration">Adding the phase aberration</a><a id="Adding-the-phase-aberration-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-the-phase-aberration" title="Permalink"></a></h3><p>Now we can add some phase to our configuration. To add a modal phase represented by Zernike polynomials, we need to create the basis first. This creates it for the first 10 radial orders:</p><pre><code class="language-julia hljs">using PhaseBases
z10 = ZernikeBW(conf2, 10);</code></pre><p>The basis now contains 60 Zernike polynomials (in Born and Wolf form, normed by <em>rms</em> value), numbered in OSA/ANSI indexes. Elements of basis can be accessed as follows:</p><ul><li>by double indexing:</li></ul><pre><code class="language-julia hljs">using PhasePlots
showphasetight(z10(; m=10, n=10) .* conf2.mask)[1]</code></pre><img src="6235c31b.png" alt="Example block output"/><ul><li>by single index:</li></ul><pre><code class="language-julia hljs">showphasetight(z10(12) .* conf2.mask)[1]</code></pre><img src="679e8382.png" alt="Example block output"/><p>This is a combination of some low-order Zernike polynomials</p><pre><code class="language-julia hljs">phase = ModalPhase([4, 6, 15, 16], [2, 1, 0.4, 0.3] * 2π, z10)
showphasetight(phase .* conf2.mask)[1]</code></pre><img src="28fe534f.png" alt="Example block output"/><p>To apply this phase to the simulation configuration, apply it literally:</p><pre><code class="language-julia hljs">phase(conf2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Simulation configuration with the properties:

name:		 10mm aperture
wavelength:	 6.33e-7
Imaging Sensor made with:
  Imaging Lens with 
  f:	300.0 mm and 
  D:	10.0 mm and 
  Camera with 
	pixel size 5.3 × 5.3 μm², 
	(1280, 1024) frame and 
	8/8 bit/channel output.
with wavefront aberrrations: [&quot;aberration&quot;]
with phase diversities ()
</code></pre><p>and check the PSF</p><pre><code class="language-julia hljs">p2 = psf(conf2)
save(&quot;psf2_ab.png&quot;, Gray.(p2));</code></pre><p><img src="../psf2_ab.png" alt/></p><p>For this aberrated phase the PSF is larger and more details are visible in the logarithmic scale</p><pre><code class="language-julia hljs">showarray(logrescale(float(p2)))</code></pre><img src="0cdbe250.png" alt="Example block output"/><p>The <code>SimConfig</code>type is callable and, if applied to an array of proper dimensions, generates a PSF:</p><pre><code class="language-julia hljs">p2 = conf2(phase)
showarray(p2; colormap=:grays)</code></pre><img src="5e4def5d.png" alt="Example block output"/><h3 id="Adding-some-diversity"><a class="docs-heading-anchor" href="#Adding-some-diversity">Adding some diversity</a><a id="Adding-some-diversity-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-some-diversity" title="Permalink"></a></h3><p>This creates a defocus of 1λ/4 amplitude:</p><pre><code class="language-julia hljs">defocus = 2π / 4 * z10(; n=2, m=0)
showphase(collect(defocus .* conf2.mask))[1]</code></pre><img src="064dc493.png" alt="Example block output"/><p>Or we could better create diversities corresponding in the depth-of-focus lengths, which is approximately the same</p><pre><code class="language-julia hljs">defocus = ZonalPhase(throughfocus(conf2, doflength(conf2)))
showphase(collect(-(defocus .+ π / 2) .* conf2.mask))[1]</code></pre><img src="d0b556c0.png" alt="Example block output"/><p>And now we add several diversities to our <code>conf2</code></p><pre><code class="language-julia hljs">conf2.diversity = NamedTuple(zip(Symbol.(&quot;d=&quot;, -2:2), [k * defocus for k in -2:2]))

div_psf = diversed_psfs(conf2)
for (p, d) in zip(div_psf, collect(keys(conf2.diversity)))
    fig, ax, hm = showarray(logrescale(float(crop(p, 256))))
    ax.title = &quot;PSF # $d&quot;
    save(&quot;psf2_div_fig_$d.png&quot;, fig)
end</code></pre><p><img src="../psf2_div_fig_d=-2.png" alt/> <img src="../psf2_div_fig_d=-1.png" alt/> <img src="../psf2_div_fig_d=0.png" alt/> <img src="../psf2_div_fig_d=1.png" alt/> <img src="../psf2_div_fig_d=2.png" alt/></p><h2 id="tutorial-inverse"><a class="docs-heading-anchor" href="#tutorial-inverse">Inverse problem</a><a id="tutorial-inverse-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial-inverse" title="Permalink"></a></h2><p>The goal of the inverse problem is from the given PSF and <code>SimConfig</code> to restore the unknown phase.</p><p>In mathematics, the (2D) phase retrieval (PR) problem can be described as</p><p class="math-container">\[\text{find }x \mathbb{C}^{M \times N} \text{s.t.}\\
\abs{x} = a, \abs{\F x} = A\]</p><p>for some real arrays <span>$a$</span> and <span>$A.$</span></p><p>As for the PSF <span>$p$</span> one has <span>$p = \abs{\F (a e^{i \phi})}$</span>, we can from the PRproblem by passing to <code>PRproblem</code> object two arrays corresponding to the square root of the intensities in the pupil and focal planes. This PR problem we try to solve using successive applications of the DRAP algorithm with β = 0.9 and Alternating projections algorithm with the default number of iterations.</p><pre><code class="language-julia hljs">using FFTW
a = sqrt.(Float64.(conf2.ap))
A = sqrt.(collect(Float64, p2))
pr = PRproblem(a, A)
sol = solve(pr, (DRAPparam(; β=0.9, keephistory=true), APparam(; maxϵ=0.001)))
showphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]</code></pre><img src="aa097a44.png" alt="Example block output"/><p>This doesn&#39;t work at the moment.  It might work if we let it iterate further</p><pre><code class="language-julia hljs">sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true, maxit =1500), APparam(maxϵ = 0.001)))
showphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]</code></pre><p><img src="../../assets/PR_DRAP1500.png" alt="Output after 1500 iterations"/></p><p>The phase is perfectly reconstructed now, and so here is the main problem of the AP-based PR algorithms –- they require quite a long time to converge, even for the noiseless data.</p><p>Here is an attempt with the initial guess given by the simple subset method</p><pre><code class="language-julia hljs">th = 0.6 * maximum(A)
xth = copy(A)
xth[A .&gt; th] .*= 1
xth[A .&lt;= th] .= 0
showarray(xth)

alg = DRAPparam(; x⁰=ifft(xth), β=0.95, keephistory=true, maxit=200)
sol = solve(pr, (alg, APparam(; maxit=50)))
showphasetight(fftshift(angle.(sol[1])) .* conf2.mask)[1]</code></pre><img src="b2140015.png" alt="Example block output"/><p>Let&#39;s try to have a smaller crop</p><pre><code class="language-julia hljs">cropw = 128
pcrop = crop(p2, cropw)
showarray(pcrop)</code></pre><img src="1e9691d7.png" alt="Example block output"/><p>Construct the corresponding sim config and see how it works TODO #5 wrap all this in functions</p><pre><code class="language-julia hljs">ims2crop = PhaseRetrieval.ImagingSensor(; lens=lens2, cam=PhaseRetrieval.roi(cam, cropw))
conf2crop = SimConfig(&quot;10mm aperture&quot;, ims2crop, 633nm)
a = sqrt.(Float64.(conf2crop.ap))
A = sqrt.(collect(Float64, pcrop))
pr = PRproblem(a, A)
@time sol = solve(
    pr, (DRAPparam(; β=0.9, keephistory=true, maxit=550), APparam(; maxit=10))
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(ComplexF64[-0.5254181326402 + 0.8508441607561782im -0.8416163641351645 + 0.540075823954291im … -0.30164837657132393 + 0.9534192450920449im -0.06555882263171758 + 0.9978487063553989im; -0.8046182957052656 + 0.59379238645873im -0.954460598978909 + 0.2983369990410547im … -0.5672195381567174 + 0.8235666309007913im -0.5515556641980554 + 0.8341380876635727im; … ; -0.8052843318710963 + 0.5928888132212667im -0.7052486378060739 + 0.708960054497203im … -0.3191200660179792 + 0.9477142942177671im -0.35921977914798475 + 0.933252993710105im; -0.780491784958076 + 0.6251660368357805im -0.8902356235122956 + 0.4555003124364181im … -0.31425562328294177 + 0.9493384029075459im -0.1809547766354053 + 0.9834914177626721im], (lasty = ComplexF64[-0.5151363191878082 + 0.834194143570832im -0.9163068406576629 + 0.5880056437254149im … -0.27171275046340737 + 0.8588017889347133im -0.0686179893547525 + 1.044411250259734im; -0.8362493188717159 + 0.6171354558773479im -1.0130936067945244 + 0.31666399505867443im … -0.4869915557670689 + 0.7070807119295808im -0.4833889390470828 + 0.7310470209760536im; … ; -0.7247703178853209 + 0.5336105480043197im -0.6528235601573348 + 0.656259086477623im … -0.3321584000085719 + 0.9864351921226137im -0.3349544465211505 + 0.8702116590400688im; -0.6926785532669021 + 0.5548285251590085im -0.8476797821829456 + 0.43372607816680303im … -0.3268766130655991 + 0.9874652951432743im -0.18364476118385759 + 0.9981115165879573im], errhist = [1.1308558115531286, 1.6552320009470451, 0.9164379238270828, 0.7782890566852074, 0.7344615008703511, 0.6979312917404664, 0.6658312191766171, 0.6589608570730494, 0.663124198967275, 0.6282612603620824  …  0.3942958448664712, 0.38966208886858383, 0.3896365768427384, 0.3874786768048714, 0.3828253127465287, 0.3663423640663958, 0.3801632628244451, 0.38152569272215364, 0.3844313102124404, 0.3919284886238158], xhist = Matrix{ComplexF64}[], disthist = [1.1653506346855973, 0.9236646144982529, 0.8751176323179448, 0.8829744652049729, 0.9050513910527188, 0.9099235442844693, 0.9060836428783742, 0.9113413589169346, 0.9141784823457312, 0.8814625929026159  …  0.6568570381572684, 0.6558397685739191, 0.6535649951648127, 0.651611984701357, 0.6482438332604232, 0.6413256578129513, 0.6473604854857432, 0.6499570681255383, 0.6538915741909639, 0.6562494368222863], distgthist = Float64[], k = 560))</code></pre><p>sol = solve(pr, (DRAPparam(β = 0.9,keephistory = true), APparam(maxϵ = 0.001)))</p><pre><code class="language-julia hljs">showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]</code></pre><img src="014047fd.png" alt="Example block output"/><p>You can try to change slightly the values of <code>β</code> above and see that algorithm might converge to another solution. This is another problem of AP-based algorithms.</p><pre><code class="language-julia hljs">@time sol = solve(
    pr, (DRAPparam(; β=0.91, keephistory=true, maxit=550), APparam(; maxit=10))
)
showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]</code></pre><img src="d683e311.png" alt="Example block output"/><p>Douglas-Rachford is known to eventually find the solution if you run it long enough: For instance, starting with <code>b</code>=0.9 would require about 20000 iterations to converge:</p><pre><code class="language-julia hljs">sol = solve(pr, (DRAPparam(; β=0.9, keephistory=true, maxit=20000), APparam(; maxit=100)))
showphasetight(fftshift(angle.(sol[1])) .* conf2crop.mask)[1]</code></pre><img src="48257cc8.png" alt="Example block output"/><p>Fortunately, julia is fast, so the calculations of 20K iterations take less than a minute.</p><h2 id="Using-phase-diversity"><a class="docs-heading-anchor" href="#Using-phase-diversity">Using phase diversity</a><a id="Using-phase-diversity-1"></a><a class="docs-heading-anchor-permalink" href="#Using-phase-diversity" title="Permalink"></a></h2><p>To use phase-diverse Phase Retrieval, we need to construct the phase diversities for the cropped configuration</p><pre><code class="language-julia hljs">z10 = ZernikeBW(conf2crop, 10);</code></pre><p>Then we know, that cropped PSFs correspond to different values of the same defocus</p><pre><code class="language-julia hljs"># defocus = 2π / 4 * z10(; n=2, m=0)
defocus = ZonalPhase(throughfocus(conf2crop, doflength(conf2crop)))
phases = [collect(k * defocus) for k in -2:2] #TODO #3 this should be automatized</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Matrix{Float64}}:
 [161.61605677026068 159.10611274936633 … 156.6358318627547 159.10611274936633; 159.10611274936633 156.59630846876982 … 154.12616509902193 156.59630846876982; … ; 156.6358318627547 154.12616509902193 … 151.65615705809742 154.12616509902193; 159.10611274936633 156.59630846876982 … 154.12616509902193 156.59630846876982]
 [80.80802838513034 79.55305637468317 … 78.31791593137736 79.55305637468317; 79.55305637468317 78.29815423438491 … 77.06308254951097 78.29815423438491; … ; 78.31791593137736 77.06308254951097 … 75.82807852904871 77.06308254951097; 79.55305637468317 78.29815423438491 … 77.06308254951097 78.29815423438491]
 [-0.0 -0.0 … -0.0 -0.0; -0.0 -0.0 … -0.0 -0.0; … ; -0.0 -0.0 … -0.0 -0.0; -0.0 -0.0 … -0.0 -0.0]
 [-80.80802838513034 -79.55305637468317 … -78.31791593137736 -79.55305637468317; -79.55305637468317 -78.29815423438491 … -77.06308254951097 -78.29815423438491; … ; -78.31791593137736 -77.06308254951097 … -75.82807852904871 -77.06308254951097; -79.55305637468317 -78.29815423438491 … -77.06308254951097 -78.29815423438491]
 [-161.61605677026068 -159.10611274936633 … -156.6358318627547 -159.10611274936633; -159.10611274936633 -156.59630846876982 … -154.12616509902193 -156.59630846876982; … ; -156.6358318627547 -154.12616509902193 … -151.65615705809742 -154.12616509902193; -159.10611274936633 -156.59630846876982 … -154.12616509902193 -156.59630846876982]</code></pre><p>Crop the corresponding PSFs</p><pre><code class="language-julia hljs">div_psf_crop = crop.(div_psf, cropw)
save(&quot;psf_crop.png&quot;, Gray.(mosaicview(div_psf_crop; nrow=1, npad=5, fillvalue=1)))</code></pre><p><img src="../psf_crop.png" alt/></p><p>Now the set corresponding to the pupil phase will be phase-diversed set</p><pre><code class="language-julia hljs">a = sqrt.(Float64.(conf2crop.ap))
A = [sqrt.(collect(Float64, p)) for p in div_psf_crop]
pr = PDPRproblem(a, A, phases)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PDPRproblem{Float64, 2}([1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [[78.75248931664578 83.07933107114764 … 75.51024398495697 76.16973461978101; 76.16973461978101 83.07933107114764 … 69.29295215421631 71.42554021067616; … ; 80.01260915836129 75.51024398495697 … 88.33152879720004 84.86618777445918; 80.01260915836129 80.63528476857272 … 82.47510973529663 81.25318870720676], [78.26534091594331 73.99860274404051 … 82.31120196733457 81.74548253532589; 79.44232938073365 72.73357614831113 … 85.62706520459395 84.53623002478663; … ; 73.99860274404051 77.67015858304113 … 66.74490699638073 70.13510449001897; 76.46589714092559 75.85659741375524 … 75.24236384390423 76.46589714092559], [64.08098129291571 69.33584998981664 … 65.62532286172093 62.49849059154081; 64.08098129291571 72.16704073394276 … 60.874875679370525 60.04660748416822; … ; 67.87598438747138 65.62532286172093 … 79.43419523810947 73.54177456069884; 64.85774882066184 67.13414807642388 … 72.85765016053978 67.87598438747138], [85.41074134209971 80.38209410324788 … 86.01865464612906 87.81714854570771; 84.1817457383793 76.39368945983463 … 90.1593501573227 89.57954124836634; … ; 79.73121623241703 82.30384975195432 … 69.23766087943807 75.70853042268547; 82.93453981614192 82.30384975195432 … 78.41325411468729 82.30384975195432], [66.42747143127828 83.27124230771065 … 67.99068463384995 59.76714829944543; 71.0139540473021 88.17367373754396 … 59.76714829944543 58.88166011361033; … ; 64.0111131477478 69.51875598143272 … 89.35726594184267 73.91366681395958; 63.18512869576668 76.70383702486939 … 78.7316008263343 65.63190415217373]], [[-0.0 0.01969328677263304 … 0.078773198541336 0.01969328677263304; 0.01969328677263304 0.03938658212374841 … 0.09846651960278571 0.03938658212374841; … ; 0.078773198541336 0.09846651960278571 … 0.1575465342429612 0.09846651960278571; 0.01969328677263304 0.03938658212374841 … 0.09846651960278571 0.03938658212374841], [-0.0 0.00984664338631652 … 0.039386599270668 0.00984664338631652; 0.00984664338631652 0.019693291061874205 … 0.049233259801392856 0.019693291061874205; … ; 0.039386599270668 0.049233259801392856 … 0.0787732671214806 0.049233259801392856; 0.00984664338631652 0.019693291061874205 … 0.049233259801392856 0.019693291061874205], [0.0 -0.0 … -0.0 -0.0; -0.0 -0.0 … -0.0 -0.0; … ; -0.0 -0.0 … -0.0 -0.0; -0.0 -0.0 … -0.0 -0.0], [0.0 -0.00984664338631652 … -0.039386599270668 -0.00984664338631652; -0.00984664338631652 -0.019693291061874205 … -0.049233259801392856 -0.019693291061874205; … ; -0.039386599270668 -0.049233259801392856 … -0.0787732671214806 -0.049233259801392856; -0.00984664338631652 -0.019693291061874205 … -0.049233259801392856 -0.019693291061874205], [0.0 -0.01969328677263304 … -0.078773198541336 -0.01969328677263304; -0.01969328677263304 -0.03938658212374841 … -0.09846651960278571 -0.03938658212374841; … ; -0.078773198541336 -0.09846651960278571 … -0.1575465342429612 -0.09846651960278571; -0.01969328677263304 -0.03938658212374841 … -0.09846651960278571 -0.03938658212374841]])</code></pre><p>As expected, using phase diversities accelerates the phase retrieval a lot</p><pre><code class="language-julia hljs">@time sol = solve(pr, (DRAPparam(; β=0.9, keephistory=true, maxit=50), APparam(; maxit=50)))
showphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2crop.mask)[1]</code></pre><img src="641db960.png" alt="Example block output"/><p>And now it should be also less sensitive to the parameter choice. But they do affect the speed of the convergence</p><pre><code class="language-julia hljs">sol = solve(pr, (DRAPparam(; β=0.5, keephistory=true, maxit=50), APparam(; maxit=50)))
showphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2crop.mask)[1]</code></pre><img src="54128199.png" alt="Example block output"/><p>Try to unwrap the phase (we subtract the first diversity)</p><pre><code class="language-julia hljs">ph = phwrap(fftshift(angle.(sol[1][:, :, 1])) - phases[1])
ph_u = unwrap_LS(ph, conf2crop.ap)
fig, ax, hm = showarray(bboxview(ph_u .* conf2crop.mask))
Colorbar(fig[1, 2], hm)
fig</code></pre><img src="571dde6c.png" alt="Example block output"/><p>Now the phase is unwrapped and can be decomposed by the basis functions</p><pre><code class="language-julia hljs">restored_coef = PhaseBases.decompose(ph_u, z10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Float64}:
  0.14378364960331558
 -0.03240287356609972
  0.00028067137090359573
 12.554664091296742
  0.016700098412679415
  6.307852723085032
  0.00812566921782576
  0.02533987580733732
 -0.008858199228636843
  0.02349094444912314
  ⋮
 -0.0026324885835802003
  0.007321395981692513
 -0.11373295545177792
 -0.0007844341832551754
 -0.05499958642714298
 -0.049778351427570644
  0.0069668244308478955
  0.011948998768339991
 -0.010085436100999323</code></pre><p>and compare the restored coefficients with the original ones</p><pre><code class="language-julia hljs">fig = Figure();
ax = Axis(fig[1, 1]);
scatter!(phase.coef; label=&quot;original&quot;)
scatter!(restored_coef; label=&quot;restored&quot;)
ax.title = &quot;Original vs restored Zernike coefficients&quot;
axislegend()

err_coef = restored_coef .- phase.coef
err_coef[1] = 0
ax, _ = scatter(fig[2, 1], err_coef)
ax.title = &quot;Coefficient restoration error&quot;
fig</code></pre><img src="3d0078f2.png" alt="Example block output"/><p>The error is quite small, although we see it increasing for high-order aberrations.  We can compare the phases themselves and see the error appearing on the edges.</p><pre><code class="language-julia hljs">ph_u .-= restored_coef[1]
phase_crop = ModalPhase(phase.coef, z10)
err = (ph_u .- phase_crop)
fig, ax, hm = showarray(bboxview(err .* conf2crop.mask))
Colorbar(fig[1, 2], hm)
ax.title = &quot;Phase restoration error, rms = $(round(maskedrmse(err, z10.ap), digits = 3))&quot;
fig</code></pre><img src="36dc669e.png" alt="Example block output"/><p>Try with high-res phase</p><pre><code class="language-julia hljs">z10 = ZernikeBW(conf2, 10);
defocus = 2π / 4 * z10(; n=2, m=0)
defocus = ZonalPhase(throughfocus(conf2, doflength(conf2)))
phases = [collect(k * defocus) for k in -2:2] #TODO this should be automatized

a = sqrt.(Float64.(conf2.ap))
A = [sqrt.(collect(Float64, p)) for p in div_psf]

pr = PDPRproblem(a, A, phases)
sol = solve(pr, (DRAPparam(; β=0.5, keephistory=true, maxit=50), APparam(; maxit=50)))
showphasetight((fftshift(angle.(sol[1][:, :, 1])) - phases[1]) .* conf2.mask)[1]</code></pre><img src="6c701485.png" alt="Example block output"/><p>We again unwrap the phase and subtract the first diversity</p><pre><code class="language-julia hljs">ph = phwrap(fftshift(angle.(sol[1][:, :, 1])) - phases[1])
ph_u = unwrap_LS(ph, conf2.ap)
fig, ax, hm = showarray(bboxview(ph_u .* conf2.mask))
ax.aspect = 1
Colorbar(fig[1, 2], hm)
fig</code></pre><img src="cc981cd8.png" alt="Example block output"/><p>Now the phase is unwrapped and can be decomposed by the basis functions</p><pre><code class="language-julia hljs">restored_coef = PhaseBases.decompose(ph_u, z10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">66-element Vector{Float64}:
  0.3542642352707474
 -0.03283131129023875
 -0.0022877986438492037
 12.519260469666449
  0.0017603526467579404
  6.267625071202241
  0.0017588848261818057
  0.01819841084507523
 -0.011167707291945578
 -0.0011324700696682122
  ⋮
  0.004547659274192421
  0.002577014794666266
 -0.09339208953671385
 -0.002821263721670113
 -0.04608428343840027
 -0.052700957925998514
  0.012497655230986334
  0.006101030111302148
 -0.0009468167108972192</code></pre><p>and compare the restored coefficients with the original ones</p><pre><code class="language-julia hljs">fig = Figure();
ax = Axis(fig[1, 1]);
scatter!(phase.coef; label=&quot;original&quot;)
scatter!(restored_coef; label=&quot;restored&quot;)
ax.title = &quot;Original vs restored Zernike coefficients&quot;
axislegend()

err_coef = restored_coef .- phase.coef
err_coef[1] = 0
ax, _ = scatter(fig[2, 1], err_coef)
ax.title = &quot;Coefficient restoration error&quot;
fig</code></pre><img src="7ddd1a21.png" alt="Example block output"/><p>The error is error is about the same.</p><p>We can compare the phases themselves</p><pre><code class="language-julia hljs">ph_u .-= restored_coef[1]
err = (ph_u .- phase)
fig, ax, hm = showarray(bboxview(err .* conf2.mask));
ax.aspect = 1
Colorbar(fig[1, 2], hm)
ax.title = &quot;Phase rmse = $(PhaseUtils.maskedphasermse(ph_u, phase, conf2.ap)/(2π)) λ&quot;
fig</code></pre><img src="127d1838.png" alt="Example block output"/><p>The quite big error in the coefficient restoration compared with the error magnitude in the phases <em>is not</em> the numerical error of decomposition by Zernikes. Here is, for instance, the result of the decomposition of the input phase:</p><pre><code class="language-julia hljs">rest = PhaseBases.decompose(collect(phase), z10)
scatter(phase.coef)
scatter!(rest)
current_figure()</code></pre><img src="c17274c0.png" alt="Example block output"/><p>The error is negligible:</p><pre><code class="language-julia hljs">scatter(rest .- phase.coef; axis=(title=&quot;RMS error = $( norm(rest .- phase.coef))&quot;,))</code></pre><img src="d51c7001.png" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../about/">« About</a><a class="docs-footer-nextpage" href="../Hardware/">Forward model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 22 November 2024 16:47">Friday 22 November 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
